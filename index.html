<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D Arena Duel (Bo3) ‚Äî Swords & Science</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { position:relative; height:100%; overflow:hidden; }
    canvas { display:block; width:100%; height:100%; }

    .hud { position:absolute; inset:0; pointer-events:none; padding:14px; }
    .panel {
      pointer-events:auto;
      background: rgba(10,14,20,.72);
      border: 1px solid rgba(180,220,255,.12);
      border-radius: 16px;
      padding: 12px 14px;
      box-shadow: 0 12px 28px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
    }
    .title { font-weight:800; letter-spacing:.2px; margin:0 0 6px; font-size:15px; opacity:.98; }
    .muted { opacity:.78; font-size:12px; line-height:1.4; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    button, select, label.btnlike {
      background:#122033;
      border:1px solid rgba(180,220,255,.18);
      color:#e8f2ff;
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
      user-select:none;
    }
    button:hover, label.btnlike:hover { filter:brightness(1.12); }
    button:active, label.btnlike:active { transform: translateY(1px); }
    .good { background:#122a1c; border-color: rgba(140,255,190,.22); }
    .danger { background:#2a1417; border-color: rgba(255,140,140,.22); }

    .tag {
      display:inline-flex; align-items:center; gap:6px;
      font-size:12px; padding:6px 10px; border-radius: 999px;
      border:1px solid rgba(180,220,255,.14);
      background: rgba(255,255,255,.06);
      opacity:.92;
    }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:11px;
      padding:2px 6px;
      border-radius:6px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(180,220,255,.12);
      margin: 0 2px;
    }

    #topHUD { display:flex; justify-content:space-between; gap:12px; align-items:flex-start; }
    #scorePanel { min-width: min(560px, 92vw); }
    .bars { display:flex; gap:10px; align-items:center; }
    .barWrap {
      width: 260px; max-width: 38vw;
      height: 14px; border-radius: 10px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(180,220,255,.12);
      overflow:hidden;
    }
    .bar { height:100%; width:50%; }

    .screen {
      pointer-events:auto;
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding: 18px;
      background: radial-gradient(900px 600px at 50% 35%, rgba(80,140,255,.15), transparent 55%),
                  radial-gradient(700px 520px at 30% 70%, rgba(255,120,180,.12), transparent 55%),
                  rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
    }
    .card {
      width: min(720px, 92vw);
      border-radius: 20px;
      border: 1px solid rgba(180,220,255,.14);
      background: rgba(10,14,20,.78);
      box-shadow: 0 18px 52px rgba(0,0,0,.55);
      padding: 18px 18px 16px;
    }
    .card h1 { margin:0 0 6px; font-size:24px; letter-spacing:.2px; }
    .card p { margin:0 0 12px; opacity:.78; line-height:1.45; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width:720px){ .grid2{ grid-template-columns: 1fr; } }

    .modal {
      pointer-events:auto;
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding: 18px;
      background: rgba(0,0,0,.42);
      backdrop-filter: blur(6px);
    }
    .hidden { display:none !important; }

    #bottomHUD {
      position:absolute; left:14px; right:14px; bottom:14px;
      display:flex; justify-content:space-between; gap:12px; align-items:flex-end;
      pointer-events:none;
    }
    #bottomHUD .panel { pointer-events:auto; }

    /* Action buttons */
    #actionHUD{
      position:absolute;
      right:14px;
      bottom:92px;
      display:flex;
      flex-direction:column;
      gap:10px;
      pointer-events:none;
    }
    #actionHUD button{
      pointer-events:auto;
      min-width: 150px;
      justify-content:center;
    }
    @media (max-width:720px){
      #actionHUD{ right:14px; bottom:14px; flex-direction:row; }
      #actionHUD button{ min-width: 140px; }
    }

    #toast {
      position:absolute; left:50%; top:50%;
      transform: translate(-50%,-50%);
      text-align:center; pointer-events:none;
      padding: 14px 16px; border-radius: 18px;
      background: rgba(10,14,20,.78);
      border: 1px solid rgba(180,220,255,.12);
      box-shadow: 0 18px 44px rgba(0,0,0,.45);
      min-width: min(520px, 90vw);
    }
    #toast h2 { margin:0 0 6px; font-size:22px; letter-spacing:.2px; }
    #toast p { margin:0; opacity:.78; line-height:1.4; }

    /* checkbox style */
    .chk { display:flex; align-items:center; gap:8px; }
    .chk input { transform: scale(1.1); }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <!-- HUD -->
  <div class="hud">
    <div id="topHUD">
      <div class="panel" id="scorePanel">
        <div class="row" style="justify-content:space-between; margin-bottom:10px;">
          <span class="tag" id="roundTag">Round 1 / 3</span>
          <span class="tag" id="modeTag">Mode: 1P</span>
          <span class="tag" id="timerTag">Time: 60</span>
        </div>

        <div class="bars" style="margin-bottom:10px;">
          <div style="min-width:90px;">
            <div class="muted" id="p1Name">P1</div>
            <div class="muted" id="p1Buffs">‚Äî</div>
          </div>
          <div class="barWrap"><div class="bar" id="p1Bar"></div></div>
          <span class="tag" id="p1Rounds">0</span>
        </div>

        <div class="bars" style="margin-bottom:10px;">
          <div style="min-width:90px;">
            <div class="muted" id="p2Name">NPC</div>
            <div class="muted" id="p2Buffs">‚Äî</div>
          </div>
          <div class="barWrap"><div class="bar" id="p2Bar"></div></div>
          <span class="tag" id="p2Rounds">0</span>
        </div>

        <div class="row" style="justify-content:space-between;">
          <div class="muted" id="hintLine">Grab items. Win 2 rounds.</div>
          <button class="danger" id="backBtn">Back</button>
        </div>
      </div>

      <div class="panel muted" style="max-width:min(580px, 92vw);">
        <b>Attack (easier)</b>:
        P1 <span class="kbd">E</span> / <span class="kbd">Space</span> / <span class="kbd">Click</span>,
        P2 <span class="kbd">Shift</span> / <span class="kbd">Enter</span>
        <div style="margin-top:6px;">
          <b>Easy Swing Assist</b>: ON = auto-aim helps you hit more easily.
        </div>
        <div style="margin-top:6px;">
          <b>Science Items</b>:
          üß™ Nano-Heal, ‚ö° Photon-Boost, üõ°Ô∏è Quantum-Shield, üî• Plasma-Edge, ü™ê Gravity-Boots
        </div>
      </div>
    </div>

    <!-- On-screen action buttons -->
    <div id="actionHUD">
      <button class="good" id="p1AtkBtn">P1 Attack</button>
      <button class="good" id="p2AtkBtn">P2 Attack</button>
    </div>

    <div id="bottomHUD">
      <div class="panel muted">Tip: If input feels stuck, click the game window once (focus). Keys reset on tab-switch.</div>
      <div class="panel muted">NPC avoids obstacles + attacks reliably (even Normal).</div>
    </div>

    <div id="toast" class="hidden">
      <h2 id="toastTitle">Round 1</h2>
      <p id="toastBody">Fight!</p>
    </div>
  </div>

  <!-- HOME -->
  <div class="screen" id="homeScreen">
    <div class="card">
      <h1>2D Arena Duel</h1>
      <p>2D 1v1 sword game with science buffs. Best of 3 rounds. (Easy Swing Assist + attack buttons)</p>
      <div class="row" style="margin-bottom:12px;">
        <span class="tag">Easy attack inputs</span>
        <span class="tag">Smarter NPC pathing</span>
        <span class="tag">Obstacles + items</span>
        <span class="tag">Bo3</span>
      </div>
      <div class="row">
        <button class="good" id="toSelectBtn">Play</button>
        <button id="homeControlsBtn">Controls</button>
      </div>
      <div class="muted hidden" id="homeControlsBox" style="margin-top:12px;">
        <div><b>Player 1</b>: <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> move, <span class="kbd">E</span>/<span class="kbd">Space</span>/<span class="kbd">Click</span> swing</div>
        <div><b>Player 2</b>: <span class="kbd">‚Üë</span><span class="kbd">‚Üê</span><span class="kbd">‚Üì</span><span class="kbd">‚Üí</span> move, <span class="kbd">Shift</span>/<span class="kbd">Enter</span> swing</div>
      </div>
    </div>
  </div>

  <!-- SELECT -->
  <div class="screen hidden" id="selectScreen">
    <div class="card">
      <h1>Choose Mode</h1>
      <p>Pick 1P or 2P. Then you‚Äôll see controls + items before the match starts.</p>

      <div class="grid2" style="margin-bottom:12px;">
        <div class="panel">
          <div class="title">1 Player</div>
          <div class="muted">Fight a smart NPC that avoids obstacles, chases items, and attacks reliably.</div>
          <div style="margin-top:10px;">
            <button class="good" id="choose1p">Play 1P</button>
          </div>
        </div>
        <div class="panel">
          <div class="title">2 Player</div>
          <div class="muted">Local 2P on one keyboard. (Also has on-screen attack buttons.)</div>
          <div style="margin-top:10px;">
            <button class="good" id="choose2p">Play 2P</button>
          </div>
        </div>
      </div>

      <div class="row" style="margin-bottom:12px;">
        <label class="tag">Round Time
          <select id="timeSel" style="margin-left:8px;">
            <option value="60">60s</option>
            <option value="75">75s</option>
            <option value="90">90s</option>
          </select>
        </label>
        <label class="tag">NPC Difficulty
          <select id="aiSel" style="margin-left:8px;">
            <option value="normal">Normal</option>
            <option value="hard">Hard</option>
            <option value="insane">Insane</option>
          </select>
        </label>
        <label class="tag chk" style="padding:8px 12px;">
          <input type="checkbox" id="assistChk" checked />
          Easy Swing Assist
        </label>
      </div>

      <div class="row">
        <button id="selectBackBtn">Back</button>
      </div>
    </div>
  </div>

  <!-- PRE-GAME MODAL -->
  <div class="modal hidden" id="infoModal">
    <div class="card">
      <h1>Controls & Items</h1>
      <p>Press ‚ÄúContinue‚Äù to start Round 1.</p>

      <div class="grid2" style="margin-bottom:10px;">
        <div class="panel">
          <div class="title">Controls</div>
          <div class="muted">
            <div style="margin-bottom:6px;"><b>Player 1</b>:
              <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> move,
              <span class="kbd">E</span> / <span class="kbd">Space</span> / <span class="kbd">Click</span> swing
            </div>
            <div><b>Player 2</b>:
              <span class="kbd">‚Üë</span><span class="kbd">‚Üê</span><span class="kbd">‚Üì</span><span class="kbd">‚Üí</span> move,
              <span class="kbd">Shift</span> / <span class="kbd">Enter</span> swing
            </div>
            <div style="margin-top:8px;">
              <b>Easy Swing Assist</b> helps aim your swing at close range.
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="title">Science Items</div>
          <div class="muted">
            <div>üß™ <b>Nano-Heal</b>: +35 HP instantly</div>
            <div>‚ö° <b>Photon-Boost</b>: +35% speed for 7s</div>
            <div>üõ°Ô∏è <b>Quantum-Shield</b>: -35% incoming damage for 7s</div>
            <div>üî• <b>Plasma-Edge</b>: +35% damage for 7s</div>
            <div>ü™ê <b>Gravity-Boots</b>: -40% knockback for 7s</div>
          </div>
        </div>
      </div>

      <div class="row" style="justify-content:space-between;">
        <button id="modalBackBtn">Back</button>
        <button class="good" id="continueBtn">Continue</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Utilities =====
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a, b) => a + Math.random() * (b - a);
  const dist2 = (ax, ay, bx, by) => { const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };
  const len = (x, y) => Math.hypot(x, y) || 1;
  const norm = (x, y) => { const l=len(x,y); return [x/l, y/l]; };
  const angleTo = (ax, ay, bx, by) => Math.atan2(by - ay, bx - ax);
  const wrapAngle = (a) => { while (a > Math.PI) a -= 2*Math.PI; while (a < -Math.PI) a += 2*Math.PI; return a; };

  // ===== Canvas =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ===== UI refs =====
  const homeScreen = document.getElementById('homeScreen');
  const selectScreen = document.getElementById('selectScreen');
  const infoModal = document.getElementById('infoModal');

  const toSelectBtn = document.getElementById('toSelectBtn');
  const homeControlsBtn = document.getElementById('homeControlsBtn');
  const homeControlsBox = document.getElementById('homeControlsBox');

  const choose1p = document.getElementById('choose1p');
  const choose2p = document.getElementById('choose2p');
  const selectBackBtn = document.getElementById('selectBackBtn');

  const modalBackBtn = document.getElementById('modalBackBtn');
  const continueBtn = document.getElementById('continueBtn');

  const timeSel = document.getElementById('timeSel');
  const aiSel = document.getElementById('aiSel');
  const assistChk = document.getElementById('assistChk');

  const backBtn = document.getElementById('backBtn');

  const roundTag = document.getElementById('roundTag');
  const modeTag = document.getElementById('modeTag');
  const timerTag = document.getElementById('timerTag');
  const p1Bar = document.getElementById('p1Bar');
  const p2Bar = document.getElementById('p2Bar');
  const p1RoundsEl = document.getElementById('p1Rounds');
  const p2RoundsEl = document.getElementById('p2Rounds');
  const p1NameEl = document.getElementById('p1Name');
  const p2NameEl = document.getElementById('p2Name');
  const p1BuffsEl = document.getElementById('p1Buffs');
  const p2BuffsEl = document.getElementById('p2Buffs');
  const hintLine = document.getElementById('hintLine');

  const toast = document.getElementById('toast');
  const toastTitle = document.getElementById('toastTitle');
  const toastBody = document.getElementById('toastBody');

  const p1AtkBtn = document.getElementById('p1AtkBtn');
  const p2AtkBtn = document.getElementById('p2AtkBtn');

  // ===== Input (sticky bug fixed) =====
  const keys = new Set();
  const pressedOnce = new Set();

  function clearInput() {
    keys.clear();
    pressedOnce.clear();
    mousePressedOnce = false;
    p1BtnPressedOnce = false;
    p2BtnPressedOnce = false;
  }

  window.addEventListener('keydown', (e) => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    if (!keys.has(e.key)) pressedOnce.add(e.key);
    keys.add(e.key);
  });

  window.addEventListener('keyup', (e) => {
    keys.delete(e.key);
    pressedOnce.delete(e.key);
  });

  window.addEventListener('blur', clearInput);
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) clearInput();
  });

  // mouse click for P1
  let mousePressedOnce = false;
  window.addEventListener('mousedown', (e) => {
    if (e.button === 0) mousePressedOnce = true;
  });

  // on-screen attack buttons (single press)
  let p1BtnPressedOnce = false;
  let p2BtnPressedOnce = false;

  function armButton(btn, which){
    const down = (e) => { e.preventDefault(); if(which===1) p1BtnPressedOnce = true; else p2BtnPressedOnce = true; };
    btn.addEventListener('mousedown', down);
    btn.addEventListener('touchstart', down, {passive:false});
  }
  armButton(p1AtkBtn, 1);
  armButton(p2AtkBtn, 2);

  // ===== Constants =====
  const ARENA_MARGIN = 56;
  const ROUND_MAX = 3;
  const MAX_HP = 100;

  // Sword
  const SWORD_RANGE = 72;
  const SWORD_ARC = Math.PI * 0.85;
  const SWORD_COOLDOWN = 0.60;
  const SWORD_WINDUP = 0.12;
  const SWORD_ACTIVE = 0.18;
  const BASE_DAMAGE = 18;
  const BASE_KNOCKBACK = 330;

  // Assist tuning (makes hitting easier but not free)
  const ASSIST_RANGE = 115;             // if enemy is within this distance‚Ä¶
  const ASSIST_MAX_TURN = Math.PI*0.55; // max angle correction
  const ASSIST_STRENGTH = 0.70;         // 0..1

  const ITEM_RADIUS = 14;
  const ITEM_RESPAWN = 8.0;

  // ===== Items =====
  const ItemType = { HEAL:'HEAL', SPEED:'SPEED', SHIELD:'SHIELD', DAMAGE:'DAMAGE', GRAVITY:'GRAVITY' };
  const itemDefs = [
    { type: ItemType.HEAL,    emoji:'üß™', name:'Nano-Heal',     desc:'+35 HP instantly',      color:'#82ffd1' },
    { type: ItemType.SPEED,   emoji:'‚ö°', name:'Photon-Boost',  desc:'+35% speed for 7s',     color:'#8bd3ff' },
    { type: ItemType.SHIELD,  emoji:'üõ°Ô∏è', name:'Quantum-Shield',desc:'-35% damage for 7s',    color:'#c5b2ff' },
    { type: ItemType.DAMAGE,  emoji:'üî•', name:'Plasma-Edge',   desc:'+35% damage for 7s',   color:'#ffb28b' },
    { type: ItemType.GRAVITY, emoji:'ü™ê', name:'Gravity-Boots', desc:'-40% knockback for 7s',color:'#ffd98b' },
  ];
  const pickItem = () => itemDefs[(Math.random() * itemDefs.length) | 0];

  // ===== Map =====
  class Obstacle {
    constructor(x, y, w, h, r=10) { this.x=x; this.y=y; this.w=w; this.h=h; this.r=r; this.isCircle=false; }
  }
  class Pillar {
    constructor(x, y, rad) { this.x=x; this.y=y; this.rad=rad; this.isCircle=true; }
  }
  const obstacles = [];
  const arena = { x:0,y:0,w:0,h:0 };

  function computeArena() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    arena.x = ARENA_MARGIN;
    arena.y = ARENA_MARGIN + 48;
    arena.w = w - ARENA_MARGIN*2;
    arena.h = h - ARENA_MARGIN*2 - 72;
  }

  function buildMap() {
    obstacles.length = 0;
    const cx = arena.x + arena.w/2;
    const cy = arena.y + arena.h/2;

    obstacles.push(new Pillar(cx, cy, 34));
    obstacles.push(new Pillar(cx-62, cy+30, 22));
    obstacles.push(new Pillar(cx+62, cy-30, 22));

    const left = arena.x + 120, right = arena.x + arena.w - 120;
    obstacles.push(new Pillar(left, cy-120, 22));
    obstacles.push(new Pillar(left, cy+120, 22));
    obstacles.push(new Pillar(right, cy-120, 22));
    obstacles.push(new Pillar(right, cy+120, 22));

    const b = 58;
    obstacles.push(new Obstacle(arena.x+40, arena.y+40, b, b, 14));
    obstacles.push(new Obstacle(arena.x+arena.w-40-b, arena.y+40, b, b, 14));
    obstacles.push(new Obstacle(arena.x+40, arena.y+arena.h-40-b, b, b, 14));
    obstacles.push(new Obstacle(arena.x+arena.w-40-b, arena.y+arena.h-40-b, b, b, 14));

    const mw = 140, mh = 18;
    obstacles.push(new Obstacle(cx - mw/2, arena.y + 92, mw, mh, 10));
    obstacles.push(new Obstacle(cx - mw/2, arena.y + arena.h - 92 - mh, mw, mh, 10));
  }

  // ===== Entities =====
  class Player {
    constructor(id, name, x, y, isNpc=false) {
      this.id=id; this.name=name;
      this.x=x; this.y=y;
      this.vx=0; this.vy=0;
      this.r=18;
      this.hp=MAX_HP;
      this.facing=0;

      this.isNpc=isNpc;

      this.attackT=0;
      this.cooldown=0;
      this._hitLocked=false;

      this.buff={ speed:0, shield:0, damage:0, gravity:0 };

      this.ai = {
        strafeDir: Math.random()<0.5 ? -1 : 1,
        nextStrafeSwap: rand(0.5, 1.4),
        thinkTimer: 0,
        lastEnemyX: x,
        lastEnemyY: y,
        lastEnemyVX: 0,
        lastEnemyVY: 0,
        panic: 0,
        detourSide: Math.random()<0.5 ? -1 : 1,
        detourTimer: 0,
        lastBlocked: 0,
      };
    }

    get speedMul()  { return this.buff.speed   > 0 ? 1.35 : 1.0; }
    get dmgMul()    { return this.buff.damage  > 0 ? 1.35 : 1.0; }
    get shieldMul() { return this.buff.shield  > 0 ? 0.65 : 1.0; }
    get kbMul()     { return this.buff.gravity > 0 ? 0.60 : 1.0; }

    resetForRound(x, y) {
      this.x=x; this.y=y;
      this.vx=0; this.vy=0;
      this.hp=MAX_HP;
      this.facing=0;
      this.attackT=0;
      this.cooldown=0;
      this._hitLocked=false;
      this.buff.speed=this.buff.shield=this.buff.damage=this.buff.gravity=0;
    }

    startAttack() {
      if (this.cooldown > 0 || this.attackT > 0) return false;
      this.attackT = 0.0001;
      this.cooldown = SWORD_COOLDOWN;
      this._hitLocked = false;
      return true;
    }

    update(dt, inputVec, wantAttack, enemy, items, aiProfile) {
      for (const k of Object.keys(this.buff)) this.buff[k] = Math.max(0, this.buff[k] - dt);
      this.cooldown = Math.max(0, this.cooldown - dt);

      if (this.attackT > 0) {
        this.attackT += dt;
        if (this.attackT >= SWORD_WINDUP + SWORD_ACTIVE) this.attackT = 0;
      }

      const BASE_SPEED = 265 * this.speedMul;
      let ax=0, ay=0;

      if (!this.isNpc) {
        ax = inputVec[0]; ay = inputVec[1];
      } else {
        const v = this.npcBrain(dt, enemy, items, aiProfile);
        ax = v[0]; ay = v[1];
      }

      const mag = Math.hypot(ax, ay);
      if (mag > 1) { ax /= mag; ay /= mag; }

      if (mag > 0.12) this.facing = Math.atan2(ay, ax);
      else if (enemy) this.facing = angleTo(this.x, this.y, enemy.x, enemy.y);

      const ACC = 1650;
      this.vx += ax * ACC * dt;
      this.vy += ay * ACC * dt;

      const vmag = Math.hypot(this.vx, this.vy);
      if (vmag > BASE_SPEED) {
        this.vx = this.vx / vmag * BASE_SPEED;
        this.vy = this.vy / vmag * BASE_SPEED;
      }

      const F = 12;
      this.vx = lerp(this.vx, 0, 1 - Math.exp(-F*dt));
      this.vy = lerp(this.vy, 0, 1 - Math.exp(-F*dt));

      this.x += this.vx * dt;
      this.y += this.vy * dt;

      const minX = arena.x + this.r, maxX = arena.x + arena.w - this.r;
      const minY = arena.y + this.r, maxY = arena.y + arena.h - this.r;
      this.x = clamp(this.x, minX, maxX);
      this.y = clamp(this.y, minY, maxY);

      if (wantAttack) this.startAttack();
    }

    npcBrain(dt, enemy, items, diff) {
      const ex=enemy.x, ey=enemy.y;
      const evx = (ex - this.ai.lastEnemyX) / Math.max(1e-6, dt);
      const evy = (ey - this.ai.lastEnemyY) / Math.max(1e-6, dt);
      this.ai.lastEnemyVX = lerp(this.ai.lastEnemyVX, evx, 0.35);
      this.ai.lastEnemyVY = lerp(this.ai.lastEnemyVY, evy, 0.35);
      this.ai.lastEnemyX = ex; this.ai.lastEnemyY = ey;

      this.ai.thinkTimer -= dt;
      if (this.ai.thinkTimer <= 0) {
        this.ai.thinkTimer = rand(0.06, 0.12) / diff.react;
        this.ai.nextStrafeSwap -= dt;
        if (this.ai.nextStrafeSwap <= 0) {
          this.ai.strafeDir *= -1;
          this.ai.nextStrafeSwap = rand(0.5, 1.4);
        }
      }

      const dx = enemy.x - this.x;
      const dy = enemy.y - this.y;
      const d = Math.hypot(dx, dy);

      let targetItem = null;
      const wantHeal = this.hp < 55;
      if (items.length && (Math.random() < 0.09 * diff.itemGreed || wantHeal)) {
        let best=null, bestScore=Infinity;
        for (const it of items) {
          if (!it.active) continue;
          const dd = Math.hypot(it.x - this.x, it.y - this.y);
          let score = dd;
          if (wantHeal && it.def.type === ItemType.HEAL) score *= 0.35;
          if (!wantHeal && it.def.type === ItemType.DAMAGE) score *= 0.80;
          if (!wantHeal && it.def.type === ItemType.SPEED)  score *= 0.90;
          if (!wantHeal && it.def.type === ItemType.SHIELD) score *= 0.95;
          if (d < 150) score *= 1.4;
          if (score < bestScore) { bestScore=score; best=it; }
        }
        targetItem = best;
      }

      const leadT = clamp(0.18 * diff.aim, 0.10, 0.30);
      const px = enemy.x + this.ai.lastEnemyVX * leadT;
      const py = enemy.y + this.ai.lastEnemyVY * leadT;

      let tx = px, ty = py;
      if (targetItem && (wantHeal || Math.random() < 0.35 * diff.itemGreed)) { tx = targetItem.x; ty = targetItem.y; }

      const losToEnemy = hasLineOfSight(this.x, this.y, enemy.x, enemy.y);
      const losToTarget = hasLineOfSight(this.x, this.y, tx, ty);

      this.ai.detourTimer = Math.max(0, this.ai.detourTimer - dt);
      if (!losToTarget) {
        this.ai.lastBlocked += dt;
        if (this.ai.lastBlocked > 0.18 && this.ai.detourTimer <= 0) {
          this.ai.detourSide *= -1;
          this.ai.detourTimer = rand(0.35, 0.65);
          this.ai.lastBlocked = 0;
        }
      } else {
        this.ai.lastBlocked = 0;
      }

      const angToTarget = angleTo(this.x, this.y, tx, ty);
      let [nx, ny] = norm(Math.cos(angToTarget), Math.sin(angToTarget));

      const lowHp = this.hp < 35;
      this.ai.panic = lerp(this.ai.panic, lowHp ? 1 : 0, 1 - Math.exp(-2.0*dt));

      let mvx=0, mvy=0;

      if (targetItem && (wantHeal || Math.random() < 0.35 * diff.itemGreed)) {
        mvx += nx; mvy += ny;
        if (d < 130) {
          const angToEnemy = angleTo(this.x, this.y, enemy.x, enemy.y);
          const [exn, eyn] = norm(Math.cos(angToEnemy), Math.sin(angToEnemy));
          mvx -= exn * 0.35 * diff.dodge;
          mvy -= eyn * 0.35 * diff.dodge;
        }
      } else {
        const angToEnemy = angleTo(this.x, this.y, px, py);
        const [exn, eyn] = norm(Math.cos(angToEnemy), Math.sin(angToEnemy));

        const ideal = lerp(118, 92, diff.bravery);
        if (d > ideal + 45) { mvx += exn*1.0; mvy += eyn*1.0; }
        else if (d < ideal - 26) {
          mvx -= exn*(0.95 + 0.35*this.ai.panic)*diff.dodge;
          mvy -= eyn*(0.95 + 0.35*this.ai.panic)*diff.dodge;
        } else {
          const sx = -eyn * this.ai.strafeDir;
          const sy =  exn * this.ai.strafeDir;
          mvx += sx*0.95; mvy += sy*0.95;

          if (this.buff.damage>0 || this.buff.speed>0) { mvx += exn*0.25*diff.bravery; mvy += eyn*0.25*diff.bravery; }
        }

        if (d < 98 && Math.random() < 0.18 * diff.dodge) {
          const s = (Math.random()<0.5 ? -1 : 1);
          mvx += (-eyn)*1.15*s;
          mvy += ( exn)*1.15*s;
        }

        if (!losToEnemy && d > 85) {
          mvx += (-eyn) * 0.65 * this.ai.detourSide;
          mvy += ( exn) * 0.65 * this.ai.detourSide;
        }
      }

      if (!losToTarget) {
        const px2 = -ny * this.ai.detourSide;
        const py2 =  nx * this.ai.detourSide;
        mvx += px2 * 0.75;
        mvy += py2 * 0.75;
      }

      const pad=42;
      if (this.x < arena.x + pad) mvx += 0.8;
      if (this.x > arena.x + arena.w - pad) mvx -= 0.8;
      if (this.y < arena.y + pad) mvy += 0.8;
      if (this.y > arena.y + arena.h - pad) mvy -= 0.8;

      for (const ob of obstacles) {
        if (ob.isCircle) {
          const dd = Math.hypot(this.x - ob.x, this.y - ob.y);
          const safe = ob.rad + this.r + 22;
          if (dd < safe) {
            const [rx, ry] = norm(this.x - ob.x, this.y - ob.y);
            const push = (safe - dd)/safe;
            mvx += rx * (1.25*push);
            mvy += ry * (1.25*push);
          }
        } else {
          const nxp = clamp(this.x, ob.x, ob.x + ob.w);
          const nyp = clamp(this.y, ob.y, ob.y + ob.h);
          const dd = Math.hypot(this.x - nxp, this.y - nyp);
          const safe = this.r + 18;
          if (dd < safe) {
            const [rx, ry] = norm(this.x - nxp, this.y - nyp);
            const push = (safe - dd)/safe;
            mvx += rx * (1.35*push);
            mvy += ry * (1.35*push);
          }
        }
      }

      const m = Math.hypot(mvx, mvy);
      if (m > 1) { mvx/=m; mvy/=m; }
      return [mvx, mvy];
    }

    getBuffText() {
      const parts=[];
      if (this.buff.speed>0) parts.push('‚ö°');
      if (this.buff.shield>0) parts.push('üõ°Ô∏è');
      if (this.buff.damage>0) parts.push('üî•');
      if (this.buff.gravity>0) parts.push('ü™ê');
      return parts.join(' ') || '‚Äî';
    }
  }

  class Item {
    constructor(def, x, y) { this.def=def; this.x=x; this.y=y; this.r=ITEM_RADIUS; this.active=true; this.respawnT=0; }
    update(dt) { if (!this.active) { this.respawnT -= dt; if (this.respawnT<=0) this.active=true; } }
    despawn() { this.active=false; this.respawnT=ITEM_RESPAWN; }
  }

  // ===== Confetti =====
  const confetti = [];
  function spawnConfetti(cx, cy, count=180) {
    for (let i=0;i<count;i++){
      const a=rand(0,Math.PI*2), s=rand(110,560);
      confetti.push({ x:cx,y:cy, vx:Math.cos(a)*s, vy:Math.sin(a)*s - rand(140,420),
        g:rand(560,960), life:rand(1.0,1.8), t:0, rot:rand(0,Math.PI*2), vr:rand(-9,9), size:rand(4,9), hue:rand(0,360) });
    }
  }
  function updateConfetti(dt){
    for (let i=confetti.length-1;i>=0;i--){
      const p=confetti[i];
      p.t+=dt; p.vy+=p.g*dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.rot+=p.vr*dt;
      if (p.t>=p.life) confetti.splice(i,1);
    }
  }
  function drawConfetti(){
    for (const p of confetti){
      ctx.save();
      ctx.translate(p.x,p.y); ctx.rotate(p.rot);
      ctx.globalAlpha = 1 - (p.t/p.life);
      ctx.fillStyle = `hsl(${p.hue} 90% 60%)`;
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*1.6);
      ctx.restore();
    }
  }

  // ===== Game State =====
  const GameState = { HOME:'HOME', SELECT:'SELECT', INFO:'INFO', BETWEEN:'BETWEEN', PLAY:'PLAY', MATCH_OVER:'MATCH_OVER' };
  let state = GameState.HOME;

  let mode = '1p';
  let roundTime = 60;
  let aiDifficulty = 'normal';
  let easyAssist = true;

  const items = [];
  const p1 = new Player(1,'P1',0,0,false);
  const p2 = new Player(2,'NPC',0,0,true);

  let currentRound=1, p1Rounds=0, p2Rounds=0, timeLeft=60;
  let freezeT=0;

  function getAIProfile(){
    if (aiDifficulty==='hard')   return { react:1.25, bravery:0.70, itemGreed:1.10, dodge:1.25, aim:1.18 };
    if (aiDifficulty==='insane') return { react:1.55, bravery:0.82, itemGreed:1.20, dodge:1.45, aim:1.32 };
    return { react:1.0, bravery:0.62, itemGreed:1.0, dodge:1.10, aim:1.05 };
  }

  function setToast(show, title='', body=''){
    toastTitle.textContent = title;
    toastBody.textContent = body;
    toast.classList.toggle('hidden', !show);
  }

  function resetItems(){
    items.length=0;
    const count=5;
    for (let i=0;i<count;i++){
      const def=pickItem();
      let x=0,y=0, ok=false;
      for (let t=0;t<30 && !ok;t++){
        x = rand(arena.x+70, arena.x+arena.w-70);
        y = rand(arena.y+70, arena.y+arena.h-70);
        ok = true;
        for (const ob of obstacles){
          if (ob.isCircle){
            if (Math.hypot(x-ob.x, y-ob.y) < ob.rad + 46) { ok=false; break; }
          } else {
            const nxp = clamp(x, ob.x, ob.x+ob.w);
            const nyp = clamp(y, ob.y, ob.y+ob.h);
            if (Math.hypot(x-nxp, y-nyp) < 46) { ok=false; break; }
          }
        }
      }
      items.push(new Item(def,x,y));
    }
  }

  function startMatch(){
    roundTime = parseInt(timeSel.value,10);
    aiDifficulty = aiSel.value;
    easyAssist = !!assistChk.checked;

    p2.isNpc = (mode==='1p');
    p1NameEl.textContent='P1';
    p2NameEl.textContent = (mode==='1p') ? 'NPC' : 'P2';

    p1Rounds=0; p2Rounds=0;
    currentRound=1;
    timeLeft=roundTime;

    computeArena();
    buildMap();
    resetItems();

    const cx=arena.x+arena.w/2, cy=arena.y+arena.h/2;
    p1.resetForRound(cx-180, cy);
    p2.resetForRound(cx+180, cy);

    state = GameState.BETWEEN;
    freezeT = 1.2;
    setToast(true, `Round ${currentRound}`, 'Fight!');
  }

  function endRound(winner){
    if (winner===p1) p1Rounds++; else p2Rounds++;

    if (p1Rounds>=2 || p2Rounds>=2 || currentRound>=ROUND_MAX) {
      endMatch();
      return;
    }
    state = GameState.BETWEEN;
    freezeT = 1.5;
    setToast(true, `Round ${currentRound} Over`, `${winner.name} wins the round!`);
  }

  function startNextRound(){
    currentRound++;
    if (currentRound>ROUND_MAX || p1Rounds>=2 || p2Rounds>=2) { endMatch(); return; }

    timeLeft=roundTime;
    computeArena();
    buildMap();
    resetItems();

    const cx=arena.x+arena.w/2, cy=arena.y+arena.h/2;
    p1.resetForRound(cx-180, cy);
    p2.resetForRound(cx+180, cy);

    state=GameState.BETWEEN;
    freezeT=1.2;
    setToast(true, `Round ${currentRound}`, 'Fight!');
  }

  function endMatch(){
    state = GameState.MATCH_OVER;
    const champ = (p1Rounds>p2Rounds)? p1 : p2;
    setToast(true, 'Congrats you beat the game!', `${champ.name} wins the match (${p1Rounds}-${p2Rounds}).`);
    spawnConfetti(window.innerWidth/2, window.innerHeight/2, 230);
  }

  function goHome(){
    clearInput();
    state = GameState.HOME;
    homeScreen.classList.remove('hidden');
    selectScreen.classList.add('hidden');
    infoModal.classList.add('hidden');
    setToast(false);
    confetti.length=0;
  }
  function goSelect(){
    clearInput();
    state = GameState.SELECT;
    homeScreen.classList.add('hidden');
    selectScreen.classList.remove('hidden');
    infoModal.classList.add('hidden');
  }
  function openInfoModal(){
    clearInput();
    state = GameState.INFO;
    infoModal.classList.remove('hidden');
  }
  function closeInfoModalBackToSelect(){
    clearInput();
    state = GameState.SELECT;
    infoModal.classList.add('hidden');
  }

  // ===== Collisions / LOS =====
  function resolvePlayerCollision(a,b){
    const dx=b.x-a.x, dy=b.y-a.y;
    const d=Math.hypot(dx,dy);
    const minD=a.r+b.r;
    if (d<minD && d>1e-6){
      const overlap=minD-d;
      const nx=dx/d, ny=dy/d;
      a.x -= nx*overlap*0.5; a.y -= ny*overlap*0.5;
      b.x += nx*overlap*0.5; b.y += ny*overlap*0.5;
    }
  }

  function collideWithObstacles(pl){
    for (const ob of obstacles){
      if (ob.isCircle){
        const dx = pl.x - ob.x, dy = pl.y - ob.y;
        const d = Math.hypot(dx,dy);
        const minD = pl.r + ob.rad;
        if (d < minD && d > 1e-6){
          const overlap = minD - d;
          const nx=dx/d, ny=dy/d;
          pl.x += nx*overlap;
          pl.y += ny*overlap;
          pl.vx = lerp(pl.vx, 0, 0.35);
          pl.vy = lerp(pl.vy, 0, 0.35);
        }
      } else {
        const nxp = clamp(pl.x, ob.x, ob.x+ob.w);
        const nyp = clamp(pl.y, ob.y, ob.y+ob.h);
        const dx = pl.x - nxp, dy = pl.y - nyp;
        const d = Math.hypot(dx,dy);
        const minD = pl.r;
        if (d < minD && d > 1e-6){
          const overlap = minD - d;
          const nx=dx/d, ny=dy/d;
          pl.x += nx*overlap;
          pl.y += ny*overlap;
          pl.vx = lerp(pl.vx, 0, 0.35);
          pl.vy = lerp(pl.vy, 0, 0.35);
        }
      }
    }
  }

  function hasLineOfSight(ax, ay, bx, by){
    const steps = 18;
    for (let i=1;i<steps;i++){
      const t = i/steps;
      const x = lerp(ax,bx,t);
      const y = lerp(ay,by,t);
      for (const ob of obstacles){
        if (ob.isCircle){
          if (Math.hypot(x-ob.x, y-ob.y) < ob.rad-2) return false;
        } else {
          if (x > ob.x && x < ob.x+ob.w && y > ob.y && y < ob.y+ob.h) return false;
        }
      }
    }
    return true;
  }

  // ===== Easy Swing Assist =====
  function applyAssist(attacker, defender){
    if (!easyAssist) return;

    const dx = defender.x - attacker.x;
    const dy = defender.y - attacker.y;
    const d = Math.hypot(dx, dy);
    if (d > ASSIST_RANGE) return;

    // no assist if obstacle blocks and not very close
    if (!hasLineOfSight(attacker.x, attacker.y, defender.x, defender.y) && d > 70) return;

    const targetAng = Math.atan2(dy, dx);
    const delta = wrapAngle(targetAng - attacker.facing);

    // limit correction so it still feels like skill
    const limited = clamp(delta, -ASSIST_MAX_TURN, ASSIST_MAX_TURN) * ASSIST_STRENGTH;
    attacker.facing = wrapAngle(attacker.facing + limited);
  }

  function attemptSwordHit(attacker, defender){
    const d2 = dist2(attacker.x, attacker.y, defender.x, defender.y);
    if (d2 > SWORD_RANGE*SWORD_RANGE) return false;

    const angToDef = angleTo(attacker.x, attacker.y, defender.x, defender.y);
    const diff = Math.abs(wrapAngle(angToDef - attacker.facing));
    if (diff > (SWORD_ARC * 0.5)) return false;

    if (!hasLineOfSight(attacker.x, attacker.y, defender.x, defender.y)) {
      if (d2 > (48*48)) return false;
    }

    const dmg = BASE_DAMAGE * attacker.dmgMul;
    const final = dmg * defender.shieldMul;
    defender.hp = Math.max(0, defender.hp - final);

    const [nx, ny] = norm(defender.x - attacker.x, defender.y - attacker.y);
    const kb = BASE_KNOCKBACK * defender.kbMul;
    defender.vx += nx * kb * (0.010 + Math.random()*0.004);
    defender.vy += ny * kb * (0.010 + Math.random()*0.004);
    return true;
  }

  function checkItemPickups(pl){
    for (const it of items){
      if (!it.active) continue;
      const d2 = dist2(pl.x, pl.y, it.x, it.y);
      if (d2 <= (pl.r + it.r + 2) ** 2) {
        applyItem(pl, it);
        it.despawn();
      }
    }
  }

  function applyItem(pl, it){
    const t = it.def.type;
    if (t==='HEAL'){ pl.hp = Math.min(MAX_HP, pl.hp + 35); return; }
    const DUR=7.0;
    if (t==='SPEED')   pl.buff.speed   = Math.max(pl.buff.speed, DUR);
    if (t==='SHIELD')  pl.buff.shield  = Math.max(pl.buff.shield, DUR);
    if (t==='DAMAGE')  pl.buff.damage  = Math.max(pl.buff.damage, DUR);
    if (t==='GRAVITY') pl.buff.gravity = Math.max(pl.buff.gravity, DUR);
  }

  // ===== Controls =====
  function getMoveVecP1(){
    let x=0,y=0;
    if (keys.has('w')||keys.has('W')) y-=1;
    if (keys.has('s')||keys.has('S')) y+=1;
    if (keys.has('a')||keys.has('A')) x-=1;
    if (keys.has('d')||keys.has('D')) x+=1;
    return [x,y];
  }
  function getMoveVecP2(){
    let x=0,y=0;
    if (keys.has('ArrowUp')) y-=1;
    if (keys.has('ArrowDown')) y+=1;
    if (keys.has('ArrowLeft')) x-=1;
    if (keys.has('ArrowRight')) x+=1;
    return [x,y];
  }

  function wantsAttackP1Once(){
    const key = pressedOnce.has('e') || pressedOnce.has('E') || pressedOnce.has(' ') || mousePressedOnce || p1BtnPressedOnce;
    mousePressedOnce = false;
    p1BtnPressedOnce = false;
    pressedOnce.delete('e'); pressedOnce.delete('E'); pressedOnce.delete(' ');
    return key;
  }
  function wantsAttackP2Once(){
    const key = pressedOnce.has('Shift') || pressedOnce.has('Enter') || p2BtnPressedOnce;
    p2BtnPressedOnce = false;
    pressedOnce.delete('Shift'); pressedOnce.delete('Enter');
    return key;
  }

  // ===== Rendering =====
  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawArena(){
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0,0,window.innerWidth, window.innerHeight);

    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = 'rgba(180,220,255,.08)';
    const step = 46;
    for (let x=0; x<window.innerWidth; x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,window.innerHeight); ctx.stroke();
    }
    for (let y=0; y<window.innerHeight; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(window.innerWidth,y); ctx.stroke();
    }
    ctx.restore();

    ctx.save();
    ctx.fillStyle = 'rgba(180,220,255,.05)';
    ctx.strokeStyle = 'rgba(180,220,255,.18)';
    ctx.lineWidth = 2;
    roundRect(ctx, arena.x, arena.y, arena.w, arena.h, 18);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    drawObstacles();
  }

  function drawObstacles(){
    for (const ob of obstacles){
      if (ob.isCircle){
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = 'rgba(140,200,255,.9)';
        ctx.beginPath();
        ctx.arc(ob.x, ob.y, ob.rad+10, 0, Math.PI*2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.fillStyle = 'rgba(10,14,20,.85)';
        ctx.beginPath();
        ctx.arc(ob.x, ob.y, ob.rad+2, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(180,220,255,.20)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ob.x, ob.y, ob.rad+2, 0, Math.PI*2);
        ctx.stroke();

        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(255,120,180,.55)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ob.x, ob.y, ob.rad-8, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.save();
        ctx.fillStyle = 'rgba(10,14,20,.82)';
        roundRect(ctx, ob.x, ob.y, ob.w, ob.h, ob.r);
        ctx.fill();
        ctx.strokeStyle = 'rgba(180,220,255,.18)';
        ctx.lineWidth = 2;
        roundRect(ctx, ob.x, ob.y, ob.w, ob.h, ob.r);
        ctx.stroke();

        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(140,255,190,.35)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(ob.x+10, ob.y+10);
        ctx.lineTo(ob.x+ob.w-10, ob.y+10);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function drawItem(it){
    if (!it.active) return;
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = it.def.color;
    ctx.beginPath();
    ctx.arc(it.x,it.y,it.r+10,0,Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 1;
    ctx.fillStyle = 'rgba(10,14,20,.86)';
    ctx.beginPath();
    ctx.arc(it.x,it.y,it.r+2,0,Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(180,220,255,.18)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(it.x,it.y,it.r+2,0,Math.PI*2);
    ctx.stroke();

    ctx.font = '18px system-ui, Apple Color Emoji, Segoe UI Emoji';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillStyle='#e8f2ff';
    ctx.fillText(it.def.emoji, it.x, it.y+0.5);
    ctx.restore();
  }

  function drawSword(pl){
    let swing = 0;
    let alpha = 0.0;
    let active = false;

    if (pl.attackT > 0){
      const t = pl.attackT;
      if (t < SWORD_WINDUP){
        const u = t / SWORD_WINDUP;
        swing = lerp(-SWORD_ARC*0.55, -SWORD_ARC*0.20, u);
        alpha = 0.85;
      } else if (t < SWORD_WINDUP + SWORD_ACTIVE){
        const u = (t - SWORD_WINDUP) / SWORD_ACTIVE;
        const uu = 1 - Math.pow(1-u, 2);
        swing = lerp(-SWORD_ARC*0.20, +SWORD_ARC*0.65, uu);
        alpha = 0.95;
        active = true;
      }
    }

    const base = pl.facing + 0.25;
    const ang = base + swing;

    const handOffset = 18;
    const handleLen = 16;
    const bladeLen = 44;
    const bladeW = 5;

    const hx = pl.x + Math.cos(pl.facing) * handOffset;
    const hy = pl.y + Math.sin(pl.facing) * handOffset;

    ctx.save();
    ctx.translate(hx, hy);
    ctx.rotate(ang);

    if (active){
      ctx.globalAlpha = 0.20;
      ctx.strokeStyle = 'rgba(255,255,255,.85)';
      ctx.lineWidth = 7;
      ctx.beginPath();
      ctx.arc(0,0, bladeLen+10, -0.25, 0.25);
      ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.fillStyle = 'rgba(40,26,18,.95)';
    roundRect(ctx, -handleLen*0.15, -3, handleLen, 6, 3);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,.12)';
    ctx.lineWidth = 1;
    roundRect(ctx, -handleLen*0.15, -3, handleLen, 6, 3);
    ctx.stroke();

    ctx.fillStyle = 'rgba(180,220,255,.28)';
    roundRect(ctx, handleLen*0.55, -5, 10, 10, 4);
    ctx.fill();

    ctx.save();
    ctx.translate(handleLen*0.95, 0);
    ctx.fillStyle = 'rgba(220,240,255,.92)';
    roundRect(ctx, 0, -bladeW/2, bladeLen, bladeW, 3);
    ctx.fill();

    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(255,255,255,.85)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(2, -bladeW/2);
    ctx.lineTo(bladeLen-2, -bladeW/2);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.moveTo(bladeLen, -bladeW/2);
    ctx.lineTo(bladeLen+8, 0);
    ctx.lineTo(bladeLen, bladeW/2);
    ctx.closePath();
    ctx.fillStyle = 'rgba(220,240,255,.92)';
    ctx.fill();
    ctx.restore();

    if (pl.attackT > 0){
      ctx.globalAlpha = 0.18 * alpha;
      ctx.strokeStyle = 'rgba(140,200,255,.75)';
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(handleLen*0.9, 0);
      ctx.lineTo(handleLen*0.9 + bladeLen+10, 0);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawPlayer(pl, color){
    ctx.save();
    ctx.translate(pl.x, pl.y);

    ctx.globalAlpha=0.35;
    ctx.fillStyle='#000';
    ctx.beginPath();
    ctx.ellipse(0, pl.r*0.75, pl.r*1.05, pl.r*0.55, 0, 0, Math.PI*2);
    ctx.fill();

    const glow = (pl.buff.speed>0||pl.buff.shield>0||pl.buff.damage>0||pl.buff.gravity>0);
    if (glow){
      ctx.globalAlpha=0.22;
      ctx.fillStyle=color;
      ctx.beginPath();
      ctx.arc(0,0,pl.r+10,0,Math.PI*2);
      ctx.fill();
    }

    ctx.globalAlpha=1;
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.arc(0,0,pl.r,0,Math.PI*2);
    ctx.fill();

    ctx.strokeStyle='rgba(255,255,255,.22)';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(0,0,pl.r,0,Math.PI*2);
    ctx.stroke();

    ctx.rotate(pl.facing);
    ctx.strokeStyle='rgba(0,0,0,.35)';
    ctx.lineWidth=5;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(pl.r+10,0); ctx.stroke();
    ctx.strokeStyle='rgba(255,255,255,.78)';
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(pl.r+10,0); ctx.stroke();

    ctx.restore();

    drawSword(pl);

    ctx.save();
    ctx.font='12px system-ui';
    ctx.textAlign='center';
    ctx.textBaseline='bottom';
    ctx.fillStyle='rgba(232,242,255,.92)';
    ctx.fillText(pl.name, pl.x, pl.y - pl.r - 10);
    ctx.restore();
  }

  function draw(){
    drawArena();
    for (const it of items) drawItem(it);
    drawPlayer(p1, '#64b7ff');
    drawPlayer(p2, p2.isNpc ? '#ff7aa6' : '#7dffb1');
    drawConfetti();
  }

  // ===== HUD update =====
  function updateHUD(){
    roundTag.textContent = `Round ${currentRound} / ${ROUND_MAX}`;
    modeTag.textContent = `Mode: ${mode.toUpperCase()}`;
    timerTag.textContent = `Time: ${Math.ceil(timeLeft)}`;

    p1RoundsEl.textContent = String(p1Rounds);
    p2RoundsEl.textContent = String(p2Rounds);

    p1Bar.style.width = `${(p1.hp / MAX_HP) * 100}%`;
    p2Bar.style.width = `${(p2.hp / MAX_HP) * 100}%`;

    p1Bar.style.background = `linear-gradient(90deg, rgba(100,183,255,.9), rgba(100,183,255,.45))`;
    p2Bar.style.background = `linear-gradient(90deg, rgba(255,122,166,.9), rgba(255,122,166,.45))`;

    p1BuffsEl.textContent = p1.getBuffText();
    p2BuffsEl.textContent = p2.getBuffText();

    if (state === GameState.MATCH_OVER) hintLine.textContent = 'Match over ‚Äî press Back to return home.';
    else if (state === GameState.BETWEEN) hintLine.textContent = 'Get ready‚Ä¶';
    else hintLine.textContent = easyAssist ? 'Easy Swing Assist ON: hitting is easier.' : 'Assist OFF: pure skill swings.';
  }

  // ===== NPC attack (reliable) =====
  function npcTryAttack(aiProfile){
    const d = Math.hypot(p1.x - p2.x, p1.y - p2.y);
    const ang = angleTo(p2.x, p2.y, p1.x, p1.y);
    const diff = Math.abs(wrapAngle(ang - p2.facing));
    const inCone = diff <= (SWORD_ARC * 0.48);
    const canAttack = (p2.cooldown <= 0 && p2.attackT <= 0);
    if (!canAttack) return;

    const los = hasLineOfSight(p2.x, p2.y, p1.x, p1.y);
    const close = d < 92;
    const veryClose = d < 78;

    if ((veryClose && inCone) || (close && inCone && los)) { p2.startAttack(); return; }

    let prob = 0;
    if (d < 110 && inCone) prob += 0.25;
    if (d < 95  && inCone) prob += 0.22 * aiProfile.bravery;
    if (p2.buff.damage > 0) prob += 0.10;
    if (p1.hp < 40) prob += 0.08;
    if (!los && d > 60) prob -= 0.20;

    if (Math.random() < prob) p2.startAttack();
  }

  // ===== Main loop =====
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    computeArena();

    if (state === GameState.PLAY) {
      timeLeft -= dt;
      if (timeLeft <= 0) {
        const winner = (p1.hp === p2.hp) ? (Math.random()<0.5 ? p1 : p2) : (p1.hp > p2.hp ? p1 : p2);
        endRound(winner);
      }

      for (const it of items) it.update(dt);

      const aiProfile = getAIProfile();

      const p1Move = getMoveVecP1();
      const p2Move = p2.isNpc ? [0,0] : getMoveVecP2();

      const p1Atk = wantsAttackP1Once();
      const p2Atk = p2.isNpc ? false : wantsAttackP2Once();

      // apply assist right when attack is triggered
      if (p1Atk) applyAssist(p1, p2);
      if (p2Atk && !p2.isNpc) applyAssist(p2, p1);

      p1.update(dt, p1Move, p1Atk, p2, items, aiProfile);
      p2.update(dt, p2Move, p2Atk, p1, items, aiProfile);

      collideWithObstacles(p1);
      collideWithObstacles(p2);
      resolvePlayerCollision(p1, p2);

      if (p2.isNpc) npcTryAttack(aiProfile);

      const p1Active = (p1.attackT > 0 && p1.attackT >= SWORD_WINDUP && p1.attackT < SWORD_WINDUP + SWORD_ACTIVE);
      if (p1Active && !p1._hitLocked) {
        if (attemptSwordHit(p1, p2)) p1._hitLocked = true;
      }
      if (!p1Active) p1._hitLocked = false;

      const p2Active = (p2.attackT > 0 && p2.attackT >= SWORD_WINDUP && p2.attackT < SWORD_WINDUP + SWORD_ACTIVE);
      if (p2Active && !p2._hitLocked) {
        if (attemptSwordHit(p2, p1)) p2._hitLocked = true;
      }
      if (!p2Active) p2._hitLocked = false;

      checkItemPickups(p1);
      checkItemPickups(p2);

      if (p1.hp <= 0) endRound(p2);
      else if (p2.hp <= 0) endRound(p1);

    } else if (state === GameState.BETWEEN) {
      freezeT -= dt;
      if (freezeT <= 0) {
        setToast(false);
        state = GameState.PLAY;
        timeLeft = roundTime;
      }
    }

    updateConfetti(dt);
    draw();
    updateHUD();

    requestAnimationFrame(tick);
  }

  // ===== UI events =====
  homeControlsBtn.addEventListener('click', () => homeControlsBox.classList.toggle('hidden'));
  toSelectBtn.addEventListener('click', () => goSelect());
  selectBackBtn.addEventListener('click', () => goHome());

  choose1p.addEventListener('click', () => { mode='1p'; openInfoModal(); });
  choose2p.addEventListener('click', () => { mode='2p'; openInfoModal(); });

  modalBackBtn.addEventListener('click', () => closeInfoModalBackToSelect());
  continueBtn.addEventListener('click', () => {
    infoModal.classList.add('hidden');
    selectScreen.classList.add('hidden');
    homeScreen.classList.add('hidden');
    clearInput();
    startMatch();
  });

  backBtn.addEventListener('click', () => goHome());

  function init() {
    computeArena();
    buildMap();
    goHome();
    requestAnimationFrame(tick);
  }
  init();
})();
</script>
</body>
</html>
