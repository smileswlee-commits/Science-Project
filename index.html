<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D Arena Duel (Bo3) ‚Äî Swords & Science</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { position:relative; height:100%; overflow:hidden; }
    canvas { display:block; width:100%; height:100%; }

    /* UI */
    .hud { position:absolute; inset:0; pointer-events:none; padding:14px; }
    .panel {
      pointer-events:auto;
      background: rgba(10,14,20,.72);
      border: 1px solid rgba(180,220,255,.12);
      border-radius: 16px;
      padding: 12px 14px;
      box-shadow: 0 12px 28px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
    }
    .title { font-weight:800; letter-spacing:.2px; margin:0 0 6px; font-size:15px; opacity:.98; }
    .muted { opacity:.78; font-size:12px; line-height:1.4; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button, select {
      background:#122033;
      border:1px solid rgba(180,220,255,.18);
      color:#e8f2ff;
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
    }
    button:hover { filter:brightness(1.12); }
    button:active { transform: translateY(1px); }
    .good { background:#122a1c; border-color: rgba(140,255,190,.22); }
    .danger { background:#2a1417; border-color: rgba(255,140,140,.22); }

    .tag {
      display:inline-flex; align-items:center; gap:6px;
      font-size:12px; padding:6px 10px; border-radius: 999px;
      border:1px solid rgba(180,220,255,.14);
      background: rgba(255,255,255,.06);
      opacity:.92;
    }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:11px;
      padding:2px 6px;
      border-radius:6px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(180,220,255,.12);
      margin: 0 2px;
    }

    /* Layout blocks */
    #topHUD { display:flex; justify-content:space-between; gap:12px; align-items:flex-start; }
    #scorePanel { min-width: min(560px, 92vw); }
    .bars { display:flex; gap:10px; align-items:center; }
    .barWrap {
      width: 260px; max-width: 38vw;
      height: 14px; border-radius: 10px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(180,220,255,.12);
      overflow:hidden;
    }
    .bar { height:100%; width:50%; }

    /* Screens / Modals */
    .screen {
      pointer-events:auto;
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding: 18px;
      background: radial-gradient(900px 600px at 50% 35%, rgba(80,140,255,.15), transparent 55%),
                  radial-gradient(700px 520px at 30% 70%, rgba(255,120,180,.12), transparent 55%),
                  rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
    }
    .card {
      width: min(720px, 92vw);
      border-radius: 20px;
      border: 1px solid rgba(180,220,255,.14);
      background: rgba(10,14,20,.78);
      box-shadow: 0 18px 52px rgba(0,0,0,.55);
      padding: 18px 18px 16px;
    }
    .card h1 { margin:0 0 6px; font-size:24px; letter-spacing:.2px; }
    .card p { margin:0 0 12px; opacity:.78; line-height:1.45; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width:720px){ .grid2{ grid-template-columns: 1fr; } }

    .modal {
      pointer-events:auto;
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding: 18px;
      background: rgba(0,0,0,.42);
      backdrop-filter: blur(6px);
    }
    .hidden { display:none !important; }

    /* Bottom hints */
    #bottomHUD {
      position:absolute; left:14px; right:14px; bottom:14px;
      display:flex; justify-content:space-between; gap:12px; align-items:flex-end;
      pointer-events:none;
    }
    #bottomHUD .panel { pointer-events:auto; }

    /* Center toast (round banners) */
    #toast {
      position:absolute; left:50%; top:50%;
      transform: translate(-50%,-50%);
      text-align:center; pointer-events:none;
      padding: 14px 16px; border-radius: 18px;
      background: rgba(10,14,20,.78);
      border: 1px solid rgba(180,220,255,.12);
      box-shadow: 0 18px 44px rgba(0,0,0,.45);
      min-width: min(520px, 90vw);
    }
    #toast h2 { margin:0 0 6px; font-size:22px; letter-spacing:.2px; }
    #toast p { margin:0; opacity:.78; line-height:1.4; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <!-- HUD -->
  <div class="hud">
    <div id="topHUD">
      <div class="panel" id="scorePanel">
        <div class="row" style="justify-content:space-between; margin-bottom:10px;">
          <span class="tag" id="roundTag">Round 1 / 3</span>
          <span class="tag" id="modeTag">Mode: 1P</span>
          <span class="tag" id="timerTag">Time: 60</span>
        </div>

        <div class="bars" style="margin-bottom:10px;">
          <div style="min-width:80px;">
            <div class="muted" id="p1Name">P1</div>
            <div class="muted" id="p1Buffs">‚Äî</div>
          </div>
          <div class="barWrap" title="Player 1 HP"><div class="bar" id="p1Bar"></div></div>
          <span class="tag" id="p1Rounds">0</span>
        </div>

        <div class="bars" style="margin-bottom:10px;">
          <div style="min-width:80px;">
            <div class="muted" id="p2Name">NPC</div>
            <div class="muted" id="p2Buffs">‚Äî</div>
          </div>
          <div class="barWrap" title="Player 2 HP"><div class="bar" id="p2Bar"></div></div>
          <span class="tag" id="p2Rounds">0</span>
        </div>

        <div class="row" style="justify-content:space-between;">
          <div class="muted" id="hintLine">Grab items. Win 2 rounds.</div>
          <button class="danger" id="backBtn">Back</button>
        </div>
      </div>

      <div class="panel muted" style="max-width:min(520px, 92vw);">
        <b>Science Items</b>:
        üß™ Nano-Heal, ‚ö° Photon-Boost, üõ°Ô∏è Quantum-Shield, üî• Plasma-Edge, ü™ê Gravity-Boots
        <div style="margin-top:6px;">
          <b>Attack:</b> P1 <span class="kbd">E</span>, P2 <span class="kbd">Shift</span>
        </div>
      </div>
    </div>

    <div id="bottomHUD">
      <div class="panel muted">Tip: face your opponent ‚Äî swings are directional.</div>
      <div class="panel muted">Map has obstacles. Use them to break line-of-sight.</div>
    </div>

    <div id="toast" class="hidden">
      <h2 id="toastTitle">Round 1</h2>
      <p id="toastBody">Fight!</p>
    </div>
  </div>

  <!-- HOME SCREEN -->
  <div class="screen" id="homeScreen">
    <div class="card">
      <h1>2D Arena Duel</h1>
      <p>
        A fast 1v1 sword game in a 2D arena. Grab science items for buffs. Best of 3 rounds.
      </p>
      <div class="row" style="margin-bottom:12px;">
        <span class="tag">Realistic sword swing</span>
        <span class="tag">1P vs Smart NPC</span>
        <span class="tag">2P local</span>
        <span class="tag">Bo3</span>
      </div>
      <div class="row">
        <button class="good" id="toSelectBtn">Play</button>
        <button id="homeControlsBtn">Controls</button>
      </div>
      <div class="muted hidden" id="homeControlsBox" style="margin-top:12px;">
        <div><b>Player 1</b>: <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> move, <span class="kbd">E</span> swing</div>
        <div><b>Player 2</b>: <span class="kbd">‚Üë</span><span class="kbd">‚Üê</span><span class="kbd">‚Üì</span><span class="kbd">‚Üí</span> move, <span class="kbd">Shift</span> swing</div>
      </div>
    </div>
  </div>

  <!-- MODE SELECTION -->
  <div class="screen hidden" id="selectScreen">
    <div class="card">
      <h1>Choose Mode</h1>
      <p>Select 1 Player or 2 Player. Then you‚Äôll see controls + item info before the match starts.</p>

      <div class="grid2" style="margin-bottom:12px;">
        <div class="panel">
          <div class="title">1 Player</div>
          <div class="muted">Fight a smart NPC that dodges, chases items, and times swings.</div>
          <div style="margin-top:10px;">
            <button class="good" id="choose1p">Play 1P</button>
          </div>
        </div>
        <div class="panel">
          <div class="title">2 Player</div>
          <div class="muted">Local 2P on one keyboard. P2 uses arrows + Shift.</div>
          <div style="margin-top:10px;">
            <button class="good" id="choose2p">Play 2P</button>
          </div>
        </div>
      </div>

      <div class="row" style="margin-bottom:12px;">
        <label class="tag">Round Time
          <select id="timeSel" style="margin-left:8px;">
            <option value="60">60s</option>
            <option value="75">75s</option>
            <option value="90">90s</option>
          </select>
        </label>

        <label class="tag">NPC Difficulty
          <select id="aiSel" style="margin-left:8px;">
            <option value="normal">Normal</option>
            <option value="hard">Hard</option>
            <option value="insane">Insane</option>
          </select>
        </label>
      </div>

      <div class="row">
        <button id="selectBackBtn">Back</button>
      </div>
    </div>
  </div>

  <!-- PRE-GAME POPUP -->
  <div class="modal hidden" id="infoModal">
    <div class="card">
      <h1>Controls & Items</h1>
      <p>Read this once. Press ‚ÄúContinue‚Äù to start Round 1.</p>

      <div class="grid2" style="margin-bottom:10px;">
        <div class="panel">
          <div class="title">Controls</div>
          <div class="muted">
            <div style="margin-bottom:6px;"><b>Player 1</b>: <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> move, <span class="kbd">E</span> swing</div>
            <div><b>Player 2</b>: <span class="kbd">‚Üë</span><span class="kbd">‚Üê</span><span class="kbd">‚Üì</span><span class="kbd">‚Üí</span> move, <span class="kbd">Shift</span> swing</div>
            <div style="margin-top:8px;">Swings are directional: face the enemy to land hits.</div>
          </div>
        </div>
        <div class="panel">
          <div class="title">Science Items</div>
          <div class="muted">
            <div>üß™ <b>Nano-Heal</b>: +35 HP instantly</div>
            <div>‚ö° <b>Photon-Boost</b>: +35% speed for 7s</div>
            <div>üõ°Ô∏è <b>Quantum-Shield</b>: -35% incoming damage for 7s</div>
            <div>üî• <b>Plasma-Edge</b>: +35% damage for 7s</div>
            <div>ü™ê <b>Gravity-Boots</b>: -40% knockback for 7s</div>
          </div>
        </div>
      </div>

      <div class="row" style="justify-content:space-between;">
        <button id="modalBackBtn">Back</button>
        <button class="good" id="continueBtn">Continue</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Utilities =====
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a, b) => a + Math.random() * (b - a);
  const dist2 = (ax, ay, bx, by) => { const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };
  const len = (x, y) => Math.hypot(x, y) || 1;
  const norm = (x, y) => { const l=len(x,y); return [x/l, y/l]; };
  const angleTo = (ax, ay, bx, by) => Math.atan2(by - ay, bx - ax);
  const wrapAngle = (a) => { while (a > Math.PI) a -= 2*Math.PI; while (a < -Math.PI) a += 2*Math.PI; return a; };

  // ===== Canvas =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ===== UI refs =====
  const homeScreen = document.getElementById('homeScreen');
  const selectScreen = document.getElementById('selectScreen');
  const infoModal = document.getElementById('infoModal');

  const toSelectBtn = document.getElementById('toSelectBtn');
  const homeControlsBtn = document.getElementById('homeControlsBtn');
  const homeControlsBox = document.getElementById('homeControlsBox');

  const choose1p = document.getElementById('choose1p');
  const choose2p = document.getElementById('choose2p');
  const selectBackBtn = document.getElementById('selectBackBtn');

  const modalBackBtn = document.getElementById('modalBackBtn');
  const continueBtn = document.getElementById('continueBtn');

  const timeSel = document.getElementById('timeSel');
  const aiSel = document.getElementById('aiSel');

  const backBtn = document.getElementById('backBtn');

  const roundTag = document.getElementById('roundTag');
  const modeTag = document.getElementById('modeTag');
  const timerTag = document.getElementById('timerTag');
  const p1Bar = document.getElementById('p1Bar');
  const p2Bar = document.getElementById('p2Bar');
  const p1RoundsEl = document.getElementById('p1Rounds');
  const p2RoundsEl = document.getElementById('p2Rounds');
  const p1NameEl = document.getElementById('p1Name');
  const p2NameEl = document.getElementById('p2Name');
  const p1BuffsEl = document.getElementById('p1Buffs');
  const p2BuffsEl = document.getElementById('p2Buffs');
  const hintLine = document.getElementById('hintLine');

  const toast = document.getElementById('toast');
  const toastTitle = document.getElementById('toastTitle');
  const toastBody = document.getElementById('toastBody');

  // ===== Input =====
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    // prevent scroll
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    keys.add(e.key);
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key));

  // ===== Constants =====
  const ARENA_MARGIN = 56;
  const ROUND_MAX = 3;
  const MAX_HP = 100;

  // Sword (more "realistic" animation)
  const SWORD_RANGE = 72;
  const SWORD_ARC = Math.PI * 0.85;     // bigger arc feels like a real swing
  const SWORD_COOLDOWN = 0.60;
  const SWORD_WINDUP = 0.12;
  const SWORD_ACTIVE = 0.18;
  const BASE_DAMAGE = 18;
  const BASE_KNOCKBACK = 330;

  const ITEM_RADIUS = 14;
  const ITEM_RESPAWN = 8.0;

  // ===== Items =====
  const ItemType = { HEAL:'HEAL', SPEED:'SPEED', SHIELD:'SHIELD', DAMAGE:'DAMAGE', GRAVITY:'GRAVITY' };
  const itemDefs = [
    { type: ItemType.HEAL,    emoji:'üß™', name:'Nano-Heal',     desc:'+35 HP instantly',      color:'#82ffd1' },
    { type: ItemType.SPEED,   emoji:'‚ö°', name:'Photon-Boost',  desc:'+35% speed for 7s',     color:'#8bd3ff' },
    { type: ItemType.SHIELD,  emoji:'üõ°Ô∏è', name:'Quantum-Shield',desc:'-35% damage for 7s',    color:'#c5b2ff' },
    { type: ItemType.DAMAGE,  emoji:'üî•', name:'Plasma-Edge',   desc:'+35% damage for 7s',   color:'#ffb28b' },
    { type: ItemType.GRAVITY, emoji:'ü™ê', name:'Gravity-Boots', desc:'-40% knockback for 7s',color:'#ffd98b' },
  ];
  const pickItem = () => itemDefs[(Math.random() * itemDefs.length) | 0];

  // ===== Obstacles (map upgrade) =====
  // We'll build a fun map: center ring + side pillars + corner blocks
  class Obstacle {
    constructor(x, y, w, h, r=10) {
      this.x=x; this.y=y; this.w=w; this.h=h; this.r=r;
    }
  }
  const obstacles = [];

  // circle-approx obstacle for central "reactor"
  class Pillar {
    constructor(x, y, rad) { this.x=x; this.y=y; this.rad=rad; this.isCircle=true; }
  }

  function computeArena(arena) {
    const w = window.innerWidth;
    const h = window.innerHeight;
    arena.x = ARENA_MARGIN;
    arena.y = ARENA_MARGIN + 48;
    arena.w = w - ARENA_MARGIN*2;
    arena.h = h - ARENA_MARGIN*2 - 72;
  }

  function buildMap(arena) {
    obstacles.length = 0;

    const cx = arena.x + arena.w/2;
    const cy = arena.y + arena.h/2;

    // central reactor cluster (3 circles)
    obstacles.push(new Pillar(cx, cy, 34));
    obstacles.push(new Pillar(cx-62, cy+30, 22));
    obstacles.push(new Pillar(cx+62, cy-30, 22));

    // side pillars
    const left = arena.x + 120, right = arena.x + arena.w - 120;
    obstacles.push(new Pillar(left, cy-120, 22));
    obstacles.push(new Pillar(left, cy+120, 22));
    obstacles.push(new Pillar(right, cy-120, 22));
    obstacles.push(new Pillar(right, cy+120, 22));

    // corner blocks (rectangles)
    const b = 58;
    obstacles.push(new Obstacle(arena.x+40, arena.y+40, b, b, 14));
    obstacles.push(new Obstacle(arena.x+arena.w-40-b, arena.y+40, b, b, 14));
    obstacles.push(new Obstacle(arena.x+40, arena.y+arena.h-40-b, b, b, 14));
    obstacles.push(new Obstacle(arena.x+arena.w-40-b, arena.y+arena.h-40-b, b, b, 14));

    // mid walls (rectangles)
    const mw = 140, mh = 18;
    obstacles.push(new Obstacle(cx - mw/2, arena.y + 92, mw, mh, 10));
    obstacles.push(new Obstacle(cx - mw/2, arena.y + arena.h - 92 - mh, mw, mh, 10));
  }

  // ===== Entities =====
  class Player {
    constructor(id, name, x, y, isNpc=false) {
      this.id=id; this.name=name;
      this.x=x; this.y=y;
      this.vx=0; this.vy=0;
      this.r=18;
      this.hp=MAX_HP;
      this.facing=0;

      this.isNpc=isNpc;

      // sword state
      this.attackT=0;
      this.cooldown=0;
      this._hitLocked=false;

      // buffs
      this.buff={ speed:0, shield:0, damage:0, gravity:0 };

      // npc memory
      this.ai = {
        strafeDir: Math.random()<0.5 ? -1 : 1,
        nextStrafeSwap: rand(0.5, 1.4),
        thinkTimer: 0,
        lastEnemyX: x,
        lastEnemyY: y,
        lastEnemyVX: 0,
        lastEnemyVY: 0,
        panic: 0
      };
    }

    get speedMul()  { return this.buff.speed   > 0 ? 1.35 : 1.0; }
    get dmgMul()    { return this.buff.damage  > 0 ? 1.35 : 1.0; }
    get shieldMul() { return this.buff.shield  > 0 ? 0.65 : 1.0; } // incoming multiplier
    get kbMul()     { return this.buff.gravity > 0 ? 0.60 : 1.0; }

    resetForRound(x, y) {
      this.x=x; this.y=y;
      this.vx=0; this.vy=0;
      this.hp=MAX_HP;
      this.facing=0;
      this.attackT=0;
      this.cooldown=0;
      this._hitLocked=false;
      this.buff.speed=this.buff.shield=this.buff.damage=this.buff.gravity=0;
    }

    startAttack() {
      if (this.cooldown > 0 || this.attackT > 0) return false;
      this.attackT = 0.0001;
      this.cooldown = SWORD_COOLDOWN;
      this._hitLocked = false;
      return true;
    }

    update(dt, arena, inputVec, wantAttack, enemy, items, aiProfile) {
      // buffs
      for (const k of Object.keys(this.buff)) this.buff[k] = Math.max(0, this.buff[k] - dt);
      this.cooldown = Math.max(0, this.cooldown - dt);

      // attack timeline
      let attackPhase = 'NONE';
      if (this.attackT > 0) {
        this.attackT += dt;
        if (this.attackT < SWORD_WINDUP) attackPhase = 'WINDUP';
        else if (this.attackT < SWORD_WINDUP + SWORD_ACTIVE) attackPhase = 'ACTIVE';
        else { this.attackT = 0; attackPhase = 'END'; }
      }

      // movement
      const BASE_SPEED = 265 * this.speedMul;
      let ax=0, ay=0;

      if (!this.isNpc) {
        ax = inputVec[0]; ay = inputVec[1];
      } else {
        const v = this.npcBrain(dt, enemy, items, arena, aiProfile);
        ax = v[0]; ay = v[1];
      }

      // normalize
      const mag = Math.hypot(ax, ay);
      if (mag > 1) { ax /= mag; ay /= mag; }

      // facing
      if (mag > 0.12) this.facing = Math.atan2(ay, ax);
      else if (enemy) this.facing = angleTo(this.x, this.y, enemy.x, enemy.y);

      // physics
      const ACC = 1650;
      this.vx += ax * ACC * dt;
      this.vy += ay * ACC * dt;

      // cap
      const vmag = Math.hypot(this.vx, this.vy);
      if (vmag > BASE_SPEED) {
        this.vx = this.vx / vmag * BASE_SPEED;
        this.vy = this.vy / vmag * BASE_SPEED;
      }

      // friction
      const F = 12;
      this.vx = lerp(this.vx, 0, 1 - Math.exp(-F*dt));
      this.vy = lerp(this.vy, 0, 1 - Math.exp(-F*dt));

      // move
      this.x += this.vx * dt;
      this.y += this.vy * dt;

      // arena clamp
      const minX = arena.x + this.r, maxX = arena.x + arena.w - this.r;
      const minY = arena.y + this.r, maxY = arena.y + arena.h - this.r;
      this.x = clamp(this.x, minX, maxX);
      this.y = clamp(this.y, minY, maxY);

      if (wantAttack) this.startAttack();
      return attackPhase;
    }

    npcBrain(dt, enemy, items, arena, diff) {
      // update enemy velocity estimate
      const ex=enemy.x, ey=enemy.y;
      const evx = (ex - this.ai.lastEnemyX) / Math.max(1e-6, dt);
      const evy = (ey - this.ai.lastEnemyY) / Math.max(1e-6, dt);
      this.ai.lastEnemyVX = lerp(this.ai.lastEnemyVX, evx, 0.35);
      this.ai.lastEnemyVY = lerp(this.ai.lastEnemyVY, evy, 0.35);
      this.ai.lastEnemyX = ex; this.ai.lastEnemyY = ey;

      this.ai.thinkTimer -= dt;
      if (this.ai.thinkTimer <= 0) {
        this.ai.thinkTimer = rand(0.06, 0.12) / diff.react;
        this.ai.nextStrafeSwap -= dt;
        if (this.ai.nextStrafeSwap <= 0) {
          this.ai.strafeDir *= -1;
          this.ai.nextStrafeSwap = rand(0.5, 1.4);
        }
      }

      const dx = enemy.x - this.x;
      const dy = enemy.y - this.y;
      const d = Math.hypot(dx, dy);

      // item targeting
      let targetItem = null;
      const wantHeal = this.hp < 55;
      if (items.length && (Math.random() < 0.08 * diff.itemGreed || wantHeal)) {
        let best=null, bestScore=Infinity;
        for (const it of items) {
          if (!it.active) continue;
          const dd = Math.hypot(it.x - this.x, it.y - this.y);
          let score = dd;
          if (wantHeal && it.def.type === ItemType.HEAL) score *= 0.35;
          if (!wantHeal && it.def.type === ItemType.DAMAGE) score *= 0.78;
          if (!wantHeal && it.def.type === ItemType.SPEED)  score *= 0.88;
          if (!wantHeal && it.def.type === ItemType.SHIELD) score *= 0.92;
          if (d < 150) score *= 1.5; // less greedy while in danger
          if (score < bestScore) { bestScore=score; best=it; }
        }
        targetItem = best;
      }

      // predict enemy
      const leadT = clamp(0.18 * diff.aim, 0.10, 0.30);
      const px = enemy.x + this.ai.lastEnemyVX * leadT;
      const py = enemy.y + this.ai.lastEnemyVY * leadT;

      const toEnemyAng = angleTo(this.x, this.y, px, py);
      const [nx, ny] = norm(Math.cos(toEnemyAng), Math.sin(toEnemyAng));

      const lowHp = this.hp < 35;
      this.ai.panic = lerp(this.ai.panic, lowHp ? 1 : 0, 1 - Math.exp(-2.0*dt));

      let mvx=0, mvy=0;
      if (targetItem && (wantHeal || Math.random() < 0.35 * diff.itemGreed)) {
        const ix = targetItem.x - this.x, iy = targetItem.y - this.y;
        const [inx, iny] = norm(ix, iy);
        mvx += inx; mvy += iny;

        // avoid getting hit while chasing
        if (d < 140) { mvx -= nx*0.35*diff.dodge; mvy -= ny*0.35*diff.dodge; }
      } else {
        const ideal = lerp(118, 96, diff.bravery);
        if (d > ideal + 45) { mvx += nx*0.98; mvy += ny*0.98; }
        else if (d < ideal - 28) {
          mvx -= nx*(0.95 + 0.35*this.ai.panic)*diff.dodge;
          mvy -= ny*(0.95 + 0.35*this.ai.panic)*diff.dodge;
        } else {
          // strafe
          const sx = -ny * this.ai.strafeDir;
          const sy =  nx * this.ai.strafeDir;
          mvx += sx*0.9; mvy += sy*0.9;

          if (this.buff.damage>0 || this.buff.speed>0) { mvx += nx*0.25*diff.bravery; mvy += ny*0.25*diff.bravery; }
        }

        // dodge burst
        if (d < 98 && Math.random() < 0.16 * diff.dodge) {
          const s = (Math.random()<0.5 ? -1 : 1);
          mvx += (-ny)*1.1*s;
          mvy += ( nx)*1.1*s;
        }
      }

      // wall avoid
      const pad=42;
      if (this.x < arena.x + pad) mvx += 0.8;
      if (this.x > arena.x + arena.w - pad) mvx -= 0.8;
      if (this.y < arena.y + pad) mvy += 0.8;
      if (this.y > arena.y + arena.h - pad) mvy -= 0.8;

      // obstacle avoid: simple "repulsion" from obstacle centers
      for (const ob of obstacles) {
        if (ob.isCircle) {
          const dd = Math.hypot(this.x - ob.x, this.y - ob.y);
          const safe = ob.rad + this.r + 18;
          if (dd < safe) {
            const [rx, ry] = norm(this.x - ob.x, this.y - ob.y);
            const push = (safe - dd)/safe;
            mvx += rx * (0.9*push);
            mvy += ry * (0.9*push);
          }
        } else {
          // rect: push away from nearest point
          const nxp = clamp(this.x, ob.x, ob.x + ob.w);
          const nyp = clamp(this.y, ob.y, ob.y + ob.h);
          const dd = Math.hypot(this.x - nxp, this.y - nyp);
          const safe = this.r + 14;
          if (dd < safe) {
            const [rx, ry] = norm(this.x - nxp, this.y - nyp);
            const push = (safe - dd)/safe;
            mvx += rx * (1.0*push);
            mvy += ry * (1.0*push);
          }
        }
      }

      const m = Math.hypot(mvx, mvy);
      if (m > 1) { mvx/=m; mvy/=m; }
      return [mvx, mvy];
    }

    getBuffText() {
      const parts=[];
      if (this.buff.speed>0) parts.push('‚ö°');
      if (this.buff.shield>0) parts.push('üõ°Ô∏è');
      if (this.buff.damage>0) parts.push('üî•');
      if (this.buff.gravity>0) parts.push('ü™ê');
      return parts.join(' ') || '‚Äî';
    }
  }

  class Item {
    constructor(def, x, y) { this.def=def; this.x=x; this.y=y; this.r=ITEM_RADIUS; this.active=true; this.respawnT=0; }
    update(dt) {
      if (!this.active) { this.respawnT -= dt; if (this.respawnT<=0) this.active=true; }
    }
    despawn() { this.active=false; this.respawnT=ITEM_RESPAWN; }
  }

  // ===== Confetti =====
  const confetti = [];
  function spawnConfetti(cx, cy, count=180) {
    for (let i=0;i<count;i++){
      const a=rand(0,Math.PI*2), s=rand(110,560);
      confetti.push({
        x:cx,y:cy,
        vx:Math.cos(a)*s,
        vy:Math.sin(a)*s - rand(140,420),
        g:rand(560,960),
        life:rand(1.0,1.8),
        t:0, rot:rand(0,Math.PI*2), vr:rand(-9,9),
        size:rand(4,9), hue:rand(0,360),
      });
    }
  }
  function updateConfetti(dt){
    for (let i=confetti.length-1;i>=0;i--){
      const p=confetti[i];
      p.t+=dt; p.vy+=p.g*dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.rot+=p.vr*dt;
      if (p.t>=p.life) confetti.splice(i,1);
    }
  }
  function drawConfetti(){
    for (const p of confetti){
      ctx.save();
      ctx.translate(p.x,p.y); ctx.rotate(p.rot);
      ctx.globalAlpha = 1 - (p.t/p.life);
      ctx.fillStyle = `hsl(${p.hue} 90% 60%)`;
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*1.6);
      ctx.restore();
    }
  }

  // ===== Game State =====
  const GameState = { HOME:'HOME', SELECT:'SELECT', INFO:'INFO', BETWEEN:'BETWEEN', PLAY:'PLAY', MATCH_OVER:'MATCH_OVER' };
  let state = GameState.HOME;

  let mode = '1p'; // '1p' or '2p'
  let roundTime = 60;
  let aiDifficulty = 'normal';

  const arena = { x:0,y:0,w:0,h:0 };
  const items = [];

  const p1 = new Player(1,'P1',0,0,false);
  const p2 = new Player(2,'NPC',0,0,true);

  let currentRound=1, p1Rounds=0, p2Rounds=0, timeLeft=60;
  let freezeT=0, lastWinner=null;

  function getAIProfile(){
    if (aiDifficulty==='hard')   return { react:1.25, bravery:0.65, itemGreed:1.10, dodge:1.20, aim:1.15 };
    if (aiDifficulty==='insane') return { react:1.55, bravery:0.78, itemGreed:1.20, dodge:1.40, aim:1.30 };
    return { react:1.0, bravery:0.55, itemGreed:1.0, dodge:1.0, aim:1.0 };
  }

  function setToast(show, title='', body=''){
    toastTitle.textContent = title;
    toastBody.textContent = body;
    toast.classList.toggle('hidden', !show);
  }

  function resetItems(){
    items.length=0;
    const count=5;
    for (let i=0;i<count;i++){
      const def=pickItem();
      // spawn away from obstacles by retry
      let x=0,y=0, ok=false;
      for (let t=0;t<30 && !ok;t++){
        x = rand(arena.x+70, arena.x+arena.w-70);
        y = rand(arena.y+70, arena.y+arena.h-70);
        ok = true;
        for (const ob of obstacles){
          if (ob.isCircle){
            if (Math.hypot(x-ob.x, y-ob.y) < ob.rad + 46) { ok=false; break; }
          } else {
            const nxp = clamp(x, ob.x, ob.x+ob.w);
            const nyp = clamp(y, ob.y, ob.y+ob.h);
            if (Math.hypot(x-nxp, y-nyp) < 46) { ok=false; break; }
          }
        }
      }
      items.push(new Item(def,x,y));
    }
  }

  function startMatch(){
    roundTime = parseInt(timeSel.value,10);
    aiDifficulty = aiSel.value;

    p2.isNpc = (mode==='1p');
    p1NameEl.textContent='P1';
    p2NameEl.textContent = (mode==='1p') ? 'NPC' : 'P2';

    p1Rounds=0; p2Rounds=0;
    currentRound=1;
    timeLeft=roundTime;

    computeArena(arena);
    buildMap(arena);
    resetItems();

    const cx=arena.x+arena.w/2, cy=arena.y+arena.h/2;
    p1.resetForRound(cx-180, cy);
    p2.resetForRound(cx+180, cy);

    lastWinner=null;
    state = GameState.BETWEEN;
    freezeT = 1.2;
    setToast(true, `Round ${currentRound}`, 'Fight!');
  }

  function endRound(winner){
    lastWinner = winner;
    if (winner===p1) p1Rounds++; else p2Rounds++;

    if (p1Rounds>=2 || p2Rounds>=2 || currentRound>=ROUND_MAX) {
      endMatch();
      return;
    }
    state = GameState.BETWEEN;
    freezeT = 1.6;
    setToast(true, `Round ${currentRound} Over`, `${winner.name} wins the round!`);
  }

  function startNextRound(){
    currentRound++;
    if (currentRound>ROUND_MAX || p1Rounds>=2 || p2Rounds>=2) { endMatch(); return; }

    timeLeft=roundTime;
    computeArena(arena);
    buildMap(arena);
    resetItems();

    const cx=arena.x+arena.w/2, cy=arena.y+arena.h/2;
    p1.resetForRound(cx-180, cy);
    p2.resetForRound(cx+180, cy);

    state=GameState.BETWEEN;
    freezeT=1.2;
    setToast(true, `Round ${currentRound}`, 'Fight!');
  }

  function endMatch(){
    state = GameState.MATCH_OVER;
    const champ = (p1Rounds>p2Rounds)? p1 : p2;
    setToast(true, 'Congrats you beat the game!', `${champ.name} wins the match (${p1Rounds}-${p2Rounds}).`);
    spawnConfetti(window.innerWidth/2, window.innerHeight/2, 230);
  }

  function goHome(){
    state = GameState.HOME;
    homeScreen.classList.remove('hidden');
    selectScreen.classList.add('hidden');
    infoModal.classList.add('hidden');
    setToast(false);
    confetti.length=0;
  }

  function goSelect(){
    state = GameState.SELECT;
    homeScreen.classList.add('hidden');
    selectScreen.classList.remove('hidden');
    infoModal.classList.add('hidden');
  }

  function openInfoModal(){
    state = GameState.INFO;
    infoModal.classList.remove('hidden');
  }

  function closeInfoModalBackToSelect(){
    state = GameState.SELECT;
    infoModal.classList.add('hidden');
  }

  // ===== Combat / collisions =====
  function resolvePlayerCollision(a,b){
    const dx=b.x-a.x, dy=b.y-a.y;
    const d=Math.hypot(dx,dy);
    const minD=a.r+b.r;
    if (d<minD && d>1e-6){
      const overlap=minD-d;
      const nx=dx/d, ny=dy/d;
      a.x -= nx*overlap*0.5; a.y -= ny*overlap*0.5;
      b.x += nx*overlap*0.5; b.y += ny*overlap*0.5;
    }
  }

  // player vs obstacles
  function collideWithObstacles(pl){
    for (const ob of obstacles){
      if (ob.isCircle){
        const dx = pl.x - ob.x, dy = pl.y - ob.y;
        const d = Math.hypot(dx,dy);
        const minD = pl.r + ob.rad;
        if (d < minD && d > 1e-6){
          const overlap = minD - d;
          const nx=dx/d, ny=dy/d;
          pl.x += nx*overlap;
          pl.y += ny*overlap;
          // damp velocity
          pl.vx = lerp(pl.vx, 0, 0.35);
          pl.vy = lerp(pl.vy, 0, 0.35);
        }
      } else {
        const nxp = clamp(pl.x, ob.x, ob.x+ob.w);
        const nyp = clamp(pl.y, ob.y, ob.y+ob.h);
        const dx = pl.x - nxp, dy = pl.y - nyp;
        const d = Math.hypot(dx,dy);
        const minD = pl.r;
        if (d < minD && d > 1e-6){
          const overlap = minD - d;
          const nx=dx/d, ny=dy/d;
          pl.x += nx*overlap;
          pl.y += ny*overlap;
          pl.vx = lerp(pl.vx, 0, 0.35);
          pl.vy = lerp(pl.vy, 0, 0.35);
        } else if (d < 1e-6) {
          // inside exact corner; nudge out
          pl.x += rand(-1,1)*2;
          pl.y += rand(-1,1)*2;
        }
      }
    }
  }

  function attemptSwordHit(attacker, defender){
    // in range
    const d2 = dist2(attacker.x, attacker.y, defender.x, defender.y);
    if (d2 > SWORD_RANGE*SWORD_RANGE) return false;

    // in cone
    const angToDef = angleTo(attacker.x, attacker.y, defender.x, defender.y);
    const diff = Math.abs(wrapAngle(angToDef - attacker.facing));
    if (diff > (SWORD_ARC * 0.5)) return false;

    // line-of-sight check (obstacles block swings a bit)
    if (!hasLineOfSight(attacker.x, attacker.y, defender.x, defender.y)) {
      // allow some "around-corner" hits at very close range
      if (d2 > (48*48)) return false;
    }

    const dmg = BASE_DAMAGE * attacker.dmgMul;
    const final = dmg * defender.shieldMul;
    defender.hp = Math.max(0, defender.hp - final);

    const [nx, ny] = norm(defender.x - attacker.x, defender.y - attacker.y);
    const kb = BASE_KNOCKBACK * defender.kbMul;
    defender.vx += nx * kb * (0.010 + Math.random()*0.004);
    defender.vy += ny * kb * (0.010 + Math.random()*0.004);
    return true;
  }

  // simple LOS: ray vs obstacles (rect + circles)
  function hasLineOfSight(ax, ay, bx, by){
    // sample steps along segment
    const steps = 18;
    for (let i=1;i<steps;i++){
      const t = i/steps;
      const x = lerp(ax,bx,t);
      const y = lerp(ay,by,t);
      for (const ob of obstacles){
        if (ob.isCircle){
          if (Math.hypot(x-ob.x, y-ob.y) < ob.rad-2) return false;
        } else {
          if (x > ob.x && x < ob.x+ob.w && y > ob.y && y < ob.y+ob.h) return false;
        }
      }
    }
    return true;
  }

  function checkItemPickups(pl){
    for (const it of items){
      if (!it.active) continue;
      const d2 = dist2(pl.x, pl.y, it.x, it.y);
      if (d2 <= (pl.r + it.r + 2) ** 2) {
        applyItem(pl, it);
        it.despawn();
      }
    }
  }

  function applyItem(pl, it){
    const t = it.def.type;
    if (t===ItemType.HEAL){ pl.hp = Math.min(MAX_HP, pl.hp + 35); return; }
    const DUR=7.0;
    if (t===ItemType.SPEED)   pl.buff.speed   = Math.max(pl.buff.speed, DUR);
    if (t===ItemType.SHIELD)  pl.buff.shield  = Math.max(pl.buff.shield, DUR);
    if (t===ItemType.DAMAGE)  pl.buff.damage  = Math.max(pl.buff.damage, DUR);
    if (t===ItemType.GRAVITY) pl.buff.gravity = Math.max(pl.buff.gravity, DUR);
  }

  // ===== Controls =====
  function getMoveVecP1(){
    let x=0,y=0;
    if (keys.has('w')||keys.has('W')) y-=1;
    if (keys.has('s')||keys.has('S')) y+=1;
    if (keys.has('a')||keys.has('A')) x-=1;
    if (keys.has('d')||keys.has('D')) x+=1;
    return [x,y];
  }
  function getMoveVecP2(){
    let x=0,y=0;
    if (keys.has('ArrowUp')) y-=1;
    if (keys.has('ArrowDown')) y+=1;
    if (keys.has('ArrowLeft')) x-=1;
    if (keys.has('ArrowRight')) x+=1;
    return [x,y];
  }
  function wantsAttackP1(){ return keys.has('e') || keys.has('E'); }
  function wantsAttackP2(){ return keys.has('Shift'); } // left or right shift both register as 'Shift'

  // ===== Rendering =====
  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawArena(){
    // background
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0,0,window.innerWidth, window.innerHeight);

    // subtle grid
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = 'rgba(180,220,255,.08)';
    const step = 46;
    for (let x=0; x<window.innerWidth; x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,window.innerHeight); ctx.stroke();
    }
    for (let y=0; y<window.innerHeight; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(window.innerWidth,y); ctx.stroke();
    }
    ctx.restore();

    // arena area
    ctx.save();
    ctx.fillStyle = 'rgba(180,220,255,.05)';
    ctx.strokeStyle = 'rgba(180,220,255,.18)';
    ctx.lineWidth = 2;
    roundRect(ctx, arena.x, arena.y, arena.w, arena.h, 18);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // obstacles
    drawObstacles();
  }

  function drawObstacles(){
    // stylized "lab equipment" look
    for (const ob of obstacles){
      if (ob.isCircle){
        ctx.save();
        // glow ring
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = 'rgba(140,200,255,.9)';
        ctx.beginPath();
        ctx.arc(ob.x, ob.y, ob.rad+10, 0, Math.PI*2);
        ctx.fill();

        // core
        ctx.globalAlpha = 1;
        ctx.fillStyle = 'rgba(10,14,20,.85)';
        ctx.beginPath();
        ctx.arc(ob.x, ob.y, ob.rad+2, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(180,220,255,.20)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ob.x, ob.y, ob.rad+2, 0, Math.PI*2);
        ctx.stroke();

        // inner
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(255,120,180,.55)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ob.x, ob.y, ob.rad-8, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.fillStyle = 'rgba(10,14,20,.82)';
        roundRect(ctx, ob.x, ob.y, ob.w, ob.h, ob.r);
        ctx.fill();
        ctx.strokeStyle = 'rgba(180,220,255,.18)';
        ctx.lineWidth = 2;
        roundRect(ctx, ob.x, ob.y, ob.w, ob.h, ob.r);
        ctx.stroke();

        // highlight line
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(140,255,190,.35)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(ob.x+10, ob.y+10);
        ctx.lineTo(ob.x+ob.w-10, ob.y+10);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function drawItem(it){
    if (!it.active) return;
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = it.def.color;
    ctx.beginPath();
    ctx.arc(it.x,it.y,it.r+10,0,Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 1;
    ctx.fillStyle = 'rgba(10,14,20,.86)';
    ctx.beginPath();
    ctx.arc(it.x,it.y,it.r+2,0,Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(180,220,255,.18)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(it.x,it.y,it.r+2,0,Math.PI*2);
    ctx.stroke();

    ctx.font = '18px system-ui, Apple Color Emoji, Segoe UI Emoji';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillStyle='#e8f2ff';
    ctx.fillText(it.def.emoji, it.x, it.y+0.5);
    ctx.restore();
  }

  function drawPlayer(pl, color){
    // body
    ctx.save();
    ctx.translate(pl.x, pl.y);

    // shadow
    ctx.globalAlpha=0.35;
    ctx.fillStyle='#000';
    ctx.beginPath();
    ctx.ellipse(0, pl.r*0.75, pl.r*1.05, pl.r*0.55, 0, 0, Math.PI*2);
    ctx.fill();

    // glow if buffed
    const glow = (pl.buff.speed>0||pl.buff.shield>0||pl.buff.damage>0||pl.buff.gravity>0);
    if (glow){
      ctx.globalAlpha=0.22;
      ctx.fillStyle=color;
      ctx.beginPath();
      ctx.arc(0,0,pl.r+10,0,Math.PI*2);
      ctx.fill();
    }

    // main
    ctx.globalAlpha=1;
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.arc(0,0,pl.r,0,Math.PI*2);
    ctx.fill();

    ctx.strokeStyle='rgba(255,255,255,.22)';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(0,0,pl.r,0,Math.PI*2);
    ctx.stroke();

    // face direction line
    ctx.rotate(pl.facing);
    ctx.strokeStyle='rgba(0,0,0,.35)';
    ctx.lineWidth=5;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(pl.r+10,0);
    ctx.stroke();

    ctx.strokeStyle='rgba(255,255,255,.78)';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(pl.r+10,0);
    ctx.stroke();

    ctx.restore();

    // sword (realistic-ish) rendered as blade + handle, animated swing
    drawSword(pl);

    // name
    ctx.save();
    ctx.font='12px system-ui';
    ctx.textAlign='center';
    ctx.textBaseline='bottom';
    ctx.fillStyle='rgba(232,242,255,.92)';
    ctx.fillText(pl.name, pl.x, pl.y - pl.r - 10);
    ctx.restore();
  }

  function drawSword(pl){
    // compute swing angle offset based on attack timeline
    // Windup: pull back. Active: fast slice through. End: settle.
    let swing = 0;
    let alpha = 0.0;
    let active = false;

    if (pl.attackT > 0){
      const t = pl.attackT;
      if (t < SWORD_WINDUP){
        const u = t / SWORD_WINDUP; // 0..1
        swing = lerp(-SWORD_ARC*0.55, -SWORD_ARC*0.20, u);
        alpha = 0.85;
      } else if (t < SWORD_WINDUP + SWORD_ACTIVE){
        const u = (t - SWORD_WINDUP) / SWORD_ACTIVE; // 0..1
        // fast slice through, with slight ease
        const uu = 1 - Math.pow(1-u, 2);
        swing = lerp(-SWORD_ARC*0.20, +SWORD_ARC*0.65, uu);
        alpha = 0.95;
        active = true;
      } else {
        alpha = 0.0;
      }
    }

    // resting sword angle slightly forward
    const base = pl.facing + 0.25;
    const ang = base + swing;

    const handOffset = 18;      // where sword is held from body center
    const handleLen = 16;
    const bladeLen = 44;
    const bladeW = 5;

    const hx = pl.x + Math.cos(pl.facing) * handOffset;
    const hy = pl.y + Math.sin(pl.facing) * handOffset;

    ctx.save();
    ctx.translate(hx, hy);
    ctx.rotate(ang);

    // motion trail when active
    if (active){
      ctx.globalAlpha = 0.20;
      ctx.strokeStyle = 'rgba(255,255,255,.85)';
      ctx.lineWidth = 7;
      ctx.beginPath();
      ctx.arc(0,0, bladeLen+10, -0.25, 0.25);
      ctx.stroke();
    }

    // handle
    ctx.globalAlpha = 1;
    ctx.fillStyle = 'rgba(40,26,18,.95)';
    roundRect(ctx, -handleLen*0.15, -3, handleLen, 6, 3);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,.12)';
    ctx.lineWidth = 1;
    roundRect(ctx, -handleLen*0.15, -3, handleLen, 6, 3);
    ctx.stroke();

    // guard
    ctx.fillStyle = 'rgba(180,220,255,.28)';
    roundRect(ctx, handleLen*0.55, -5, 10, 10, 4);
    ctx.fill();

    // blade
    ctx.save();
    ctx.translate(handleLen*0.95, 0);
    ctx.globalAlpha = 1;
    // blade body
    ctx.fillStyle = 'rgba(220,240,255,.92)';
    roundRect(ctx, 0, -bladeW/2, bladeLen, bladeW, 3);
    ctx.fill();
    // blade edge highlight
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(255,255,255,.85)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(2, -bladeW/2);
    ctx.lineTo(bladeLen-2, -bladeW/2);
    ctx.stroke();

    // tip
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.moveTo(bladeLen, -bladeW/2);
    ctx.lineTo(bladeLen+8, 0);
    ctx.lineTo(bladeLen, bladeW/2);
    ctx.closePath();
    ctx.fillStyle = 'rgba(220,240,255,.92)';
    ctx.fill();
    ctx.restore();

    // subtle glow when swinging
    if (pl.attackT > 0){
      ctx.globalAlpha = 0.18 * alpha;
      ctx.strokeStyle = 'rgba(140,200,255,.75)';
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(handleLen*0.9, 0);
      ctx.lineTo(handleLen*0.9 + bladeLen+10, 0);
      ctx.stroke();
    }

    ctx.restore();
  }

  function draw(){
    drawArena();
    for (const it of items) drawItem(it);
    drawPlayer(p1, '#64b7ff');
    drawPlayer(p2, p2.isNpc ? '#ff7aa6' : '#7dffb1');
    drawConfetti();
  }

  // ===== HUD update =====
  function updateHUD(){
    roundTag.textContent = `Round ${currentRound} / ${ROUND_MAX}`;
    modeTag.textContent = `Mode: ${mode.toUpperCase()}`;
    timerTag.textContent = `Time: ${Math.ceil(timeLeft)}`;

    p1RoundsEl.textContent = String(p1Rounds);
    p2RoundsEl.textContent = String(p2Rounds);

    p1Bar.style.width = `${(p1.hp / MAX_HP) * 100}%`;
    p2Bar.style.width = `${(p2.hp / MAX_HP) * 100}%`;

    p1Bar.style.background = `linear-gradient(90deg, rgba(100,183,255,.9), rgba(100,183,255,.45))`;
    p2Bar.style.background = `linear-gradient(90deg, rgba(255,122,166,.9), rgba(255,122,166,.45))`;

    p1BuffsEl.textContent = p1.getBuffText();
    p2BuffsEl.textContent = p2.getBuffText();

    if (state === GameState.MATCH_OVER) hintLine.textContent = 'Match over ‚Äî press Back to return home.';
    else if (state === GameState.BETWEEN) hintLine.textContent = lastWinner ? `Next round soon‚Ä¶` : `Get ready‚Ä¶`;
    else hintLine.textContent = 'Grab items. Win 2 rounds.';
  }

  // ===== Game loop =====
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    computeArena(arena);

    if (state === GameState.PLAY) {
      timeLeft -= dt;
      if (timeLeft <= 0) {
        const winner = (p1.hp === p2.hp) ? (Math.random()<0.5 ? p1 : p2) : (p1.hp > p2.hp ? p1 : p2);
        endRound(winner);
      }

      // items
      for (const it of items) it.update(dt);

      // controls
      const p1Move = getMoveVecP1();
      const p2Move = p2.isNpc ? [0,0] : getMoveVecP2();
      const aiProfile = getAIProfile();

      const p1Atk = wantsAttackP1();
      const p2Atk = p2.isNpc ? false : wantsAttackP2();

      p1.update(dt, arena, p1Move, p1Atk, p2, items, aiProfile);
      p2.update(dt, arena, p2Move, p2Atk, p1, items, aiProfile);

      // obstacle collision
      collideWithObstacles(p1);
      collideWithObstacles(p2);

      // player collision
      resolvePlayerCollision(p1, p2);

      // NPC decide to attack (timed, uses cone + distance + cooldown)
      if (p2.isNpc) {
        const d = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        const ang = angleTo(p2.x, p2.y, p1.x, p1.y);
        const diff = Math.abs(wrapAngle(ang - p2.facing));
        const inCone = diff <= (SWORD_ARC * 0.44);
        const canAttack = (p2.cooldown <= 0 && p2.attackT <= 0);

        let prob = 0;
        if (d < 84 && inCone) prob += 0.58 * aiProfile.bravery;
        if (d < 98 && inCone) prob += 0.22;
        if (p2.buff.damage > 0) prob += 0.12;
        if (p1.hp < 40) prob += 0.10;
        if (p1.buff.shield > 0) prob -= 0.08;

        // don't swing if a wall blocks LOS and not super close
        if (d > 55 && !hasLineOfSight(p2.x, p2.y, p1.x, p1.y)) prob -= 0.35;

        if (canAttack && Math.random() < prob) p2.startAttack();
      }

      // sword hits when active window
      const p1Active = (p1.attackT > 0 && p1.attackT >= SWORD_WINDUP && p1.attackT < SWORD_WINDUP + SWORD_ACTIVE);
      if (p1Active && !p1._hitLocked) {
        if (attemptSwordHit(p1, p2)) p1._hitLocked = true;
      }
      if (!p1Active) p1._hitLocked = false;

      const p2Active = (p2.attackT > 0 && p2.attackT >= SWORD_WINDUP && p2.attackT < SWORD_WINDUP + SWORD_ACTIVE);
      if (p2Active && !p2._hitLocked) {
        if (attemptSwordHit(p2, p1)) p2._hitLocked = true;
      }
      if (!p2Active) p2._hitLocked = false;

      // pickups
      checkItemPickups(p1);
      checkItemPickups(p2);

      // KO
      if (p1.hp <= 0) endRound(p2);
      else if (p2.hp <= 0) endRound(p1);

    } else if (state === GameState.BETWEEN) {
      freezeT -= dt;
      if (freezeT <= 0) {
        // if we just ended a round, advance
        if (lastWinner) {
          setToast(false);
          lastWinner = null;
          startNextRound();
        } else {
          setToast(false);
          state = GameState.PLAY;
          timeLeft = roundTime;
        }
      }
    }

    updateConfetti(dt);
    draw();
    updateHUD();
    requestAnimationFrame(tick);
  }

  // ===== UI Actions =====
  homeControlsBtn.addEventListener('click', () => homeControlsBox.classList.toggle('hidden'));
  toSelectBtn.addEventListener('click', () => goSelect());
  selectBackBtn.addEventListener('click', () => goHome());

  choose1p.addEventListener('click', () => {
    mode='1p';
    openInfoModal();
  });
  choose2p.addEventListener('click', () => {
    mode='2p';
    openInfoModal();
  });

  modalBackBtn.addEventListener('click', () => closeInfoModalBackToSelect());
  continueBtn.addEventListener('click', () => {
    infoModal.classList.add('hidden');
    selectScreen.classList.add('hidden');
    homeScreen.classList.add('hidden');
    state = GameState.BETWEEN;
    // start match
    startMatch();
  });

  backBtn.addEventListener('click', () => {
    // from match -> home
    goHome();
  });

  // ===== Init =====
  function initUI(){
    // start at home
    goHome();
    // keep score panel visible always (it‚Äôs fine)
    // But when in home/select/info, timer/hud still visible; that‚Äôs okay.
  }
  initUI();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
