<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Arena Tank Game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    html,body{margin:0;padding:0;height:100%;background:#0b0f1a;overflow:hidden;touch-action:none}
    canvas{display:block}

    .hud{
      position:fixed;left:12px;top:12px;color:#e8eefc;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      font-size:14px;line-height:1.3;user-select:none;
      background:rgba(0,0,0,.25);padding:10px 12px;border-radius:10px;
      border:1px solid rgba(255,255,255,.08);max-width:420px;
      z-index:30;
    }
    .bar{height:8px;background:rgba(255,255,255,.12);border-radius:999px;overflow:hidden;margin:6px 0 8px}
    .fill{height:100%;width:0%;background:rgba(100,180,255,.9)}
    .choices{margin-top:8px;display:none}
    .choices button{
      margin:4px 6px 0 0;padding:6px 10px;border-radius:10px;
      border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.08);
      color:#e8eefc;cursor:pointer
    }
    .choices button:hover{background:rgba(255,255,255,.14)}
    .btn{
      margin-top:8px;padding:6px 10px;border-radius:10px;
      border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.08);
      color:#e8eefc;cursor:pointer
    }
    .btn:hover{background:rgba(255,255,255,.14)}
    #shopPanel{display:none;margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,.12)}

    .overlay{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      background:rgba(5,8,14,.72);backdrop-filter:blur(6px);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#e8eefc;z-index:50;
    }
    .panel{
      width:min(560px,calc(100vw - 36px));
      background:rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      padding:18px 18px 16px;
      box-shadow:0 20px 60px rgba(0,0,0,.45);
      text-align:center;
      max-height:84vh;
      overflow:auto;
    }
    .title{font-size:28px;font-weight:800;letter-spacing:.3px}
    .sub{margin-top:8px;opacity:.9;line-height:1.35}
    .bigbtn{
      margin-top:14px;
      padding:10px 18px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);
      color:#e8eefc;
      font-size:16px;
      cursor:pointer;
    }
    .bigbtn:hover{background:rgba(255,255,255,.16)}

    /* Mobile touch controls */
    .touch-ui{position:fixed;left:0;right:0;bottom:0;pointer-events:none;z-index:40}
    .touch-stick{
      position:fixed;width:140px;height:140px;border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      pointer-events:auto;
      touch-action:none;
    }
    #moveStick{left:18px;bottom:18px}
    #aimStick{right:18px;bottom:18px}
    .touch-knob{
      position:absolute;left:50%;top:50%;width:62px;height:62px;border-radius:999px;
      transform:translate(-50%,-50%);
      background:rgba(255,255,255,.12);
      border:1px solid rgba(255,255,255,.18);
    }
    @media (pointer:fine){ .touch-ui{display:none !important} }

    /* Mobile HUD popup */
    .ui-btn{
      position:fixed;top:12px;right:12px;z-index:65;
      width:44px;height:44px;border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);color:#e8eefc;
      font-size:20px;line-height:44px;text-align:center;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      display:none;
    }
    .ui-backdrop{
      position:fixed;inset:0;z-index:60;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(4px);
      display:none;
    }
    @media (pointer:coarse){
      #hud{display:none}
      #hud.popup{
        display:block;
        left:50%;top:50%;
        transform:translate(-50%,-50%);
        width:min(380px,calc(100vw - 28px));
        max-height:72vh;
        overflow:auto;
        padding:14px 14px 12px;
        border-radius:18px;
        background:rgba(0,0,0,.45);
        border:1px solid rgba(255,255,255,.14);
      }
      #hud.popup .bar{margin:8px 0}
      .ui-btn{display:block}
    }

    .modeRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:10px}
    .pill{
      padding:8px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);cursor:pointer;user-select:none
    }
    .pill.active{background:rgba(100,180,255,.18);border-color:rgba(100,180,255,.35)}
    .itemsBox{
      text-align:left;margin-top:12px;padding:12px;border-radius:14px;
      border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.22)
    }
    .itemsBox b{display:block;margin-bottom:6px}
    .itemsBox .it{margin:8px 0}
    .itemsBox .it .nm{font-weight:700}
    .itemsBox .it .fx{opacity:.9}
    .itemsBox .it .use{opacity:.75;font-size:12px;margin-top:2px;line-height:1.3}

    /* Debug overlay (shows JS errors on screen) */
    #errOverlay{
      position:fixed;left:12px;right:12px;bottom:12px;z-index:9999;
      background:rgba(120,0,0,.85);border:1px solid rgba(255,255,255,.18);
      color:#fff;padding:12px;border-radius:14px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      display:none;white-space:pre-wrap;max-height:40vh;overflow:auto;
    }

    /* about:blank helper buttons */
    .miniActionRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:10px}
    .smallbtn{
      padding:8px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);color:#e8eefc;cursor:pointer;
      font-size:14px;
    }
    .smallbtn:hover{background:rgba(255,255,255,.16)}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <!-- Debug -->
  <div id="errOverlay"></div>

  <!-- Mobile HUD toggle -->
  <div id="uiBackdrop" class="ui-backdrop"></div>
  <button id="uiBtn" class="ui-btn">â˜°</button>

  <!-- Mobile Touch Controls -->
  <div id="touchUI" class="touch-ui" style="display:none">
    <div class="touch-stick" id="moveStick"><div class="touch-knob" id="moveKnob"></div></div>
    <div class="touch-stick" id="aimStick"><div class="touch-knob" id="aimKnob"></div></div>
  </div>

  <!-- Home / Mode Menu -->
  <div id="homeMenu" class="overlay">
    <div class="panel">
      <div class="title">Arena Tank Game</div>
      <div class="sub">WASD move â€¢ Mouse aim â€¢ Hold click shoot</div>

      <div class="sub" style="margin-top:10px;opacity:.9">
        Choose a mode:
        <div style="margin-top:6px;opacity:.85;font-size:13px">
          Easy: 2 NPC â€¢ Normal: 3 NPC â€¢ Hard: 5 NPC (better aim + faster shooting)
        </div>
      </div>

      <div class="modeRow" id="modeRow">
        <div class="pill active" data-mode="easy">Easy</div>
        <div class="pill" data-mode="normal">Normal</div>
        <div class="pill" data-mode="hard">Hard</div>
      </div>

      <div class="sub" style="margin-top:10px;opacity:.85">
        <b>Checkpoint:</b> Level <span id="cpTxt">1</span> / 10
      </div>
      <div class="sub" style="display:none" id="winMsg"><b>Victory!</b> You finished all 10 levels.</div>

      <div class="miniActionRow">
        <button id="startBtn" class="bigbtn" style="margin-top:0">Start</button>
        <button id="blankBtn" class="bigbtn" style="margin-top:0">Play in about:blank</button>
      </div>

      <div class="sub" style="margin-top:8px;font-size:12px;opacity:.75">
        If popups are blocked, allow popups for this site.
      </div>

      <div class="itemsBox" id="itemsDescBox">
        <b>Scientific Items (pickups)</b>
      </div>

      <div class="sub" style="margin-top:10px;font-size:12px;opacity:.75">
        Tip: Items spawn around the map â€” pick them up for temporary buffs/debuffs.
      </div>
    </div>
  </div>

  <div class="hud" id="hud">
    <div><b>Arena Tank Game</b></div>
    <div style="opacity:.85;margin-top:6px">WASD move â€¢ Mouse aim â€¢ Hold click shoot</div>

    <div style="margin-top:8px">
      <div>HP: <span id="hpTxt"></span> <span style="opacity:.75;font-size:12px">(+<span id="rgTxt"></span>/s)</span></div>
      <div class="bar"><div class="fill" id="hpFill"></div></div>

      <div>XP (Rank <span id="lvTxt"></span>): <span id="xpTxt"></span></div>
      <div class="bar"><div class="fill" id="xpFill"></div></div>

      <div>Points: <span id="ptTxt">0</span></div>
      <div>Diamonds: <span id="diaTxt">0</span></div>

      <div style="margin-top:6px;opacity:.8;font-size:12px">
        Mode: <span id="modeTxt">Easy</span> â€¢ NPCs: <span id="npcTxt">2</span> â€¢ Items: <span id="itmTxt">0</span>
      </div>

      <button id="shopBtn" class="btn">Shop / Inventory</button>

      <div id="shopPanel">
        <div><b>Shop</b> (buy upgrade trees)</div>
        <div id="shopList" style="margin-top:6px"></div>

        <div style="margin-top:10px"><b>Inventory</b> (equip one tree)</div>
        <div id="invList" style="margin-top:6px"></div>

        <div style="margin-top:10px;font-size:12px;opacity:.8">
          Your equipped tree decides which classes you can choose at Rank 5.
        </div>
      </div>

      <div id="buffTxt" style="margin-top:10px;font-size:12px;opacity:.85"></div>
    </div>

    <div class="choices" id="statChoices">
      <div style="margin-top:8px"><b>Rank up!</b> Choose a stat upgrade:</div>
      <button data-up="damage">Damage</button>
      <button data-up="bulletSpeed">Bullet Speed</button>
      <button data-up="reload">Reload</button>
      <button data-up="moveSpeed">Move Speed</button>
      <button data-up="maxHp">Max HP</button>
      <button data-up="regen">Regen</button>
    </div>

    <div class="choices" id="classChoices"></div>
  </div>

<script>
(() => {
  // =========================
  // Debug: show errors on screen
  // =========================
  const errOverlay = document.getElementById("errOverlay");
  function showErr(msg){
    if (!errOverlay) return;
    errOverlay.style.display = "block";
    errOverlay.textContent = msg;
  }
  window.addEventListener("error", (e) => {
    showErr("JS ERROR:\n" + (e.message || "Unknown") + "\n\n" + (e.filename||"") + ":" + (e.lineno||"") + ":" + (e.colno||""));
  });
  window.addEventListener("unhandledrejection", (e) => {
    showErr("PROMISE ERROR:\n" + (e.reason?.message || String(e.reason || "Unknown")));
  });

  // ---------- Canvas
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  if (!ctx) { showErr("Canvas 2D context failed. Try a different browser."); return; }

  // (tiny perf help) cap DPR
  const DPR = Math.min(1.5, window.devicePixelRatio || 1);

  function resize(){
    canvas.width = window.innerWidth * DPR;
    canvas.height = window.innerHeight * DPR;
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // ---------- HUD elements
  const hpTxt = document.getElementById("hpTxt");
  const hpFill = document.getElementById("hpFill");
  const rgTxt = document.getElementById("rgTxt");
  const xpTxt = document.getElementById("xpTxt");
  const xpFill = document.getElementById("xpFill");
  const lvTxt = document.getElementById("lvTxt");
  const ptTxt = document.getElementById("ptTxt");
  const diaTxt = document.getElementById("diaTxt");

  const shopBtn = document.getElementById("shopBtn");
  const shopPanel = document.getElementById("shopPanel");
  const shopList = document.getElementById("shopList");
  const invList = document.getElementById("invList");

  const statChoices = document.getElementById("statChoices");
  const classChoices = document.getElementById("classChoices");

  const homeMenu = document.getElementById("homeMenu");
  const startBtn = document.getElementById("startBtn");
  const blankBtn = document.getElementById("blankBtn");

  const hudEl = document.getElementById("hud");
  const uiBtn = document.getElementById("uiBtn");
  const uiBackdrop = document.getElementById("uiBackdrop");

  const cpTxt = document.getElementById("cpTxt");
  const winMsg = document.getElementById("winMsg");
  const modeRow = document.getElementById("modeRow");
  const itemsDescBox = document.getElementById("itemsDescBox");
  const modeTxt = document.getElementById("modeTxt");
  const npcTxt = document.getElementById("npcTxt");
  const itmTxt = document.getElementById("itmTxt");
  const buffTxt = document.getElementById("buffTxt");

  // ---------- Helpers
  const rand = (a, b) => a + Math.random() * (b - a);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (ax, ay, bx, by) => { const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };
  const circleHit = (ax, ay, ar, bx, by, br) => dist2(ax, ay, bx, by) <= (ar+br)*(ar+br);
  const angleTo = (ax, ay, bx, by) => Math.atan2(by - ay, bx - ax);

  // ---------- Input
  const keys = new Set();
  window.addEventListener("keydown", (e) => keys.add(e.key.toLowerCase()));
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));
  const mouse = { x: 0, y: 0, down: false };
  window.addEventListener("mousemove", (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
  window.addEventListener("mousedown", () => mouse.down = true);
  window.addEventListener("mouseup", () => mouse.down = false);

  // ---------- Touch
  const touch = {
    enabled: ("ontouchstart" in window) || (navigator.maxTouchPoints > 0),
    move: { active:false, id:null, ox:0, oy:0, vx:0, vy:0 },
    aim:  { active:false, id:null, ox:0, oy:0, vx:1, vy:0 },
    shoot:false
  };

  const touchUI = document.getElementById("touchUI");
  const moveStick = document.getElementById("moveStick");
  const aimStick  = document.getElementById("aimStick");
  const moveKnob  = document.getElementById("moveKnob");
  const aimKnob   = document.getElementById("aimKnob");

  if (touch.enabled && touchUI) touchUI.style.display = "block";
  if (touch.enabled && uiBtn) uiBtn.style.display = "block";

  function stickCenter(which){
    const knob = (which==="move") ? moveKnob : aimKnob;
    if (!knob) return;
    knob.style.left = "50%";
    knob.style.top  = "50%";
    knob.style.transform = "translate(-50%,-50%)";
  }
  function stickStart(which, e){
    if (!touch.enabled) return;
    e.preventDefault();
    const t = e.changedTouches[0];
    const stick = (which==="move") ? moveStick : aimStick;
    const rect = stick.getBoundingClientRect();
    const ox = rect.left + rect.width/2;
    const oy = rect.top  + rect.height/2;
    const S = (which==="move") ? touch.move : touch.aim;
    S.active = true; S.id = t.identifier; S.ox = ox; S.oy = oy;
    stickMove(which, e);
  }
  function stickMove(which, e){
    const S = (which==="move") ? touch.move : touch.aim;
    if (!S.active) return;
    let t=null;
    for (const ct of e.changedTouches) if (ct.identifier === S.id) { t = ct; break; }
    if (!t) return;
    e.preventDefault();
    const dx = t.clientX - S.ox;
    const dy = t.clientY - S.oy;
    const R = 46;
    const L = Math.hypot(dx,dy) || 1;
    const cx = (L > R) ? (dx/L*R) : dx;
    const cy = (L > R) ? (dy/L*R) : dy;
    S.vx = cx / R;
    S.vy = cy / R;

    const knob = (which==="move") ? moveKnob : aimKnob;
    if (knob){
      knob.style.left = "50%";
      knob.style.top  = "50%";
      knob.style.transform = `translate(calc(-50% + ${cx}px), calc(-50% + ${cy}px))`;
    }
    touch.shoot = touch.aim.active;
  }
  function stickEnd(which, e){
    const S = (which==="move") ? touch.move : touch.aim;
    if (!S.active) return;
    let ended=false;
    for (const ct of e.changedTouches) if (ct.identifier === S.id) ended = true;
    if (!ended) return;
    e.preventDefault();
    S.active = false;
    S.id = null;
    if (which==="move"){ S.vx = 0; S.vy = 0; }
    stickCenter(which);
    touch.shoot = touch.aim.active;
  }

  if (moveStick){
    moveStick.addEventListener("touchstart", (e)=>stickStart("move", e), {passive:false});
    moveStick.addEventListener("touchmove",  (e)=>stickMove("move", e),  {passive:false});
    moveStick.addEventListener("touchend",   (e)=>stickEnd("move", e),   {passive:false});
    moveStick.addEventListener("touchcancel",(e)=>stickEnd("move", e),   {passive:false});
  }
  if (aimStick){
    aimStick.addEventListener("touchstart", (e)=>stickStart("aim", e), {passive:false});
    aimStick.addEventListener("touchmove",  (e)=>stickMove("aim", e),  {passive:false});
    aimStick.addEventListener("touchend",   (e)=>stickEnd("aim", e),   {passive:false});
    aimStick.addEventListener("touchcancel",(e)=>stickEnd("aim", e),   {passive:false});
  }
  window.addEventListener("touchmove", (e)=>{ if (touch.enabled) e.preventDefault(); }, {passive:false});

  // ---------- HUD popup
  let hudOpen = false;
  function setHudOpen(v){
    hudOpen = v;
    if (!hudEl) return;
    if (hudOpen){
      hudEl.classList.add("popup");
      if (uiBackdrop) uiBackdrop.style.display = "block";
      if (uiBtn) uiBtn.textContent = "âœ•";
    } else {
      hudEl.classList.remove("popup");
      if (uiBackdrop) uiBackdrop.style.display = "none";
      if (uiBtn) uiBtn.textContent = "â˜°";
    }
  }
  if (uiBtn) uiBtn.addEventListener("click", () => setHudOpen(!hudOpen));
  if (uiBackdrop) uiBackdrop.addEventListener("click", () => setHudOpen(false));

  // ---------- World / camera
  const world = { w: 4200, h: 4200 };
  const cam = { x: 0, y: 0 };
  function updateCamera(fx, fy){
    cam.x = fx - window.innerWidth/2;
    cam.y = fy - window.innerHeight/2;
    cam.x = clamp(cam.x, 0, world.w - window.innerWidth);
    cam.y = clamp(cam.y, 0, world.h - window.innerHeight);
  }

  // ---------- Game / stage
  const UNLOCK_RANK = 5;
  const MAX_STAGE = 10;
  const CHECKPOINT_EVERY = 5;
  const game = { stage: 1, phase: "fight", state: "home", checkpointStage: 1, won: false, mode: "easy" };

  const MODE_PRESETS = {
    easy:   { name:"Easy",   npcCount:2, aimError:0.22, reloadMul:1.15, dmgMul:0.95, moveMul:0.98, xpMul:0.90 },
    normal: { name:"Normal", npcCount:3, aimError:0.12, reloadMul:1.00, dmgMul:1.00, moveMul:1.00, xpMul:1.00 },
    hard:   { name:"Hard",   npcCount:5, aimError:0.05, reloadMul:0.85, dmgMul:1.10, moveMul:1.04, xpMul:1.10 },
  };

  // ---------- Trees
  const TREES = {
    starter: { id:"starter", name:"Starter Tree", cost:0,    desc:"Balanced set",        classesAtRank10:["dual","longshot","sprayer"] },
    heavy:   { id:"heavy",   name:"Heavy Tree",   cost:3000, desc:"Slow but powerful",   classesAtRank10:["twinheavy","cannonline","fortress"] },
    speed:   { id:"speed",   name:"Speed Tree",   cost:3000, desc:"Fast & aggressive",   classesAtRank10:["splitshot","rapid","skirmisher"] },
  };

  // ---------- Scientific Items
  const ITEMS = {
    titanium: {
      id:"titanium", name:"Titanium Alloy", color:"#a7b1c7", duration: 22,
      mods: { moveSpeedMul: 0.88, damageTakenMul: 0.78 },
      effectText:"Move slower, take less damage.",
      useText:"Used in aircraft, medical implants, and high-strength lightweight parts."
    },
    graphene: {
      id:"graphene", name:"Graphene Sheet", color:"#9ad0ff", duration: 18,
      mods: { bulletSpeedMul: 1.25, reloadMul: 0.85 },
      effectText:"Faster bullets + faster reload.",
      useText:"Promising for sensors, batteries, and ultra-strong conductive films."
    },
    kevlar: {
      id:"kevlar", name:"Kevlar Weave", color:"#f6d365", duration: 20,
      mods: { damageTakenMul: 0.72, moveSpeedMul: 0.95 },
      effectText:"Big damage resistance, slightly slower.",
      useText:"Used in body armor, helmets, and cut-resistant equipment."
    },
    lithium: {
      id:"lithium", name:"Lithium-ion Cell", color:"#7ee8fa", duration: 16,
      mods: { moveSpeedMul: 1.12, reloadMul: 0.92 },
      effectText:"Quicker movement + slightly faster firing.",
      useText:"Powers phones, laptops, EVs â€” rechargeable batteries."
    },
    carbonfiber: {
      id:"carbonfiber", name:"Carbon Fiber", color:"#c3a6ff", duration: 20,
      mods: { moveSpeedMul: 1.10, maxHpMul: 0.92 },
      effectText:"Faster movement, slightly lower max HP.",
      useText:"Used in aerospace and racing: strong + lightweight structures."
    },
    silicon: {
      id:"silicon", name:"Silicon Wafer", color:"#b6ffb0", duration: 18,
      mods: { damageMul: 1.18, reloadMul: 1.10 },
      effectText:"More damage, slightly slower reload.",
      useText:"Core of CPUs, memory chips, and sensors."
    }
  };

  function renderItemDescriptions(){
    if (!itemsDescBox) return;
    let html = "";
    Object.values(ITEMS).forEach(it => {
      html += `
        <div class="it">
          <div class="nm">â€¢ ${it.name}</div>
          <div class="fx">Effect: ${it.effectText} <span style="opacity:.8">(${it.duration}s)</span></div>
          <div class="use">Real life: ${it.useText}</div>
        </div>
      `;
    });
    itemsDescBox.innerHTML = `<b>Scientific Items (pickups)</b>${html}`;
  }

  // ---------- Player
  const player = {
    id:"player",
    x: world.w/2, y: world.h/2, r:18, angle:0,
    base: { moveSpeed:240, damage:18, bulletSpeed:520, reload:0.22, maxHp:140, regen:2.0, regenDelay:1.25 },
    moveSpeed:240, damage:18, bulletSpeed:520, reload:0.22,
    maxHp:140, hp:140, regen:2.0, regenDelay:1.25,
    sinceDamaged: 999,
    rank:1, xp:0, xpNext:70, points:0,
    diamonds:0,
    ownedTrees: new Set(["starter"]),
    equippedTreeId:"starter",
    classId:"basic",
    classUnlocked:false,
    classChosen:false,
    shotCooldown:0,
    alive:true,
    effects: new Map(),
    damageTakenMul: 1.0
  };

  const DIAMONDS_PER_KILL = 50;

  // ---------- Entities
  const bullets = [];
  const enemies = [];
  const shapes = [];
  const pickups = [];
  let boss = null;

  // ---------- Mode
  function setMode(mode){
    game.mode = mode;
    const preset = MODE_PRESETS[mode];
    if (modeTxt) modeTxt.textContent = preset.name;
    if (npcTxt) npcTxt.textContent = preset.npcCount;
    if (modeRow){
      [...modeRow.querySelectorAll(".pill")].forEach(p => {
        p.classList.toggle("active", p.dataset.mode === mode);
      });
    }
  }
  if (modeRow){
    modeRow.addEventListener("click", (e) => {
      const pill = e.target.closest(".pill");
      if (!pill) return;
      const m = pill.dataset.mode;
      if (MODE_PRESETS[m]) setMode(m);
    });
  }

  // ---------- Menus
  function menusOpen(){
    if (game.state === "home") return true;
    return (statChoices && statChoices.style.display==="block") ||
           (classChoices && classChoices.style.display==="block") ||
           (shopPanel && shopPanel.style.display==="block");
  }

  // ---------- Shop toggle
  if (shopBtn){
    shopBtn.addEventListener("click", () => {
      shopPanel.style.display = (shopPanel.style.display==="block") ? "none" : "block";
      renderShopAndInventory();
    });
  }

  function renderShopAndInventory(){
    if (!shopList || !invList) return;

    shopList.innerHTML = "";
    Object.values(TREES).forEach(tree => {
      if (player.ownedTrees.has(tree.id)) return;
      const row = document.createElement("div");
      row.style.cssText="margin-bottom:8px;display:flex;gap:8px;align-items:center;justify-content:space-between";
      const left = document.createElement("div");
      left.innerHTML = `<div><b>${tree.name}</b> â€” ${tree.cost} ðŸ’Ž</div><div style="opacity:.8;font-size:12px">${tree.desc}</div>`;
      const btn = document.createElement("button");
      btn.className = "btn";
      btn.style.marginTop = "0px";
      btn.textContent = "Buy";
      btn.onclick = () => {
        if (player.diamonds < tree.cost) { alert("Not enough diamonds."); return; }
        player.diamonds -= tree.cost;
        player.ownedTrees.add(tree.id);
        updateHud();
        renderShopAndInventory();
      };
      row.appendChild(left); row.appendChild(btn);
      shopList.appendChild(row);
    });
    if (!shopList.innerHTML.trim()) shopList.innerHTML = `<div style="opacity:.8;font-size:12px">No trees available to buy right now.</div>`;

    invList.innerHTML = "";
    for (const treeId of player.ownedTrees){
      const tree = TREES[treeId];
      const row = document.createElement("div");
      row.style.cssText="margin-bottom:8px;display:flex;gap:8px;align-items:center;justify-content:space-between";
      const left = document.createElement("div");
      left.innerHTML = `<div><b>${tree.name}</b>${player.equippedTreeId===treeId ? " (equipped)" : ""}</div><div style="opacity:.8;font-size:12px">${tree.desc}</div>`;
      const btn = document.createElement("button");
      btn.className = "btn";
      btn.style.marginTop = "0px";
      btn.textContent = (player.equippedTreeId===treeId) ? "Equipped" : "Equip";
      btn.disabled = (player.equippedTreeId===treeId);
      btn.onclick = () => {
        player.equippedTreeId = treeId;
        if (player.rank >= UNLOCK_RANK && !player.classChosen) openClassChoice();
        renderShopAndInventory();
      };
      row.appendChild(left); row.appendChild(btn);
      invList.appendChild(row);
    }
  }

  // ---------- Stat upgrades
  let pendingRanks = 0;
  function showStatChoices(){ if (statChoices) statChoices.style.display="block"; }
  function hideStatChoices(){ if (statChoices) statChoices.style.display="none"; }

  if (statChoices){
    statChoices.addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn) return;
      const up = btn.getAttribute("data-up");
      applyStatUpgrade(player, up);
      recalcDerivedStats(player);
      pendingRanks--;
      if (pendingRanks <= 0) hideStatChoices();
    });
  }

  function applyStatUpgrade(entity, up){
    switch(up){
      case "damage": entity.base.damage += 3; break;
      case "bulletSpeed": entity.base.bulletSpeed += 40; break;
      case "reload": entity.base.reload = Math.max(0.08, entity.base.reload - 0.02); break;
      case "moveSpeed": entity.base.moveSpeed += 18; break;
      case "regen": entity.base.regen = Math.min(25, entity.base.regen + 1.0); break;
      case "maxHp":
        entity.base.maxHp += 18;
        entity.hp = Math.min(entity.base.maxHp, entity.hp + 18);
        break;
    }
  }

  // ---------- Classes
  const CLASSES = {
    dual: {
      name:"Dual Cannons",
      applyBaseMods(p){ p.base.damage=Math.max(10, p.base.damage-3); p.base.reload=Math.max(0.10, p.base.reload-0.01); },
      fire(p,a){ const s=0.10; fireBullet(p,a-s,p.bulletSpeed,p.damage); fireBullet(p,a+s,p.bulletSpeed,p.damage); }
    },
    longshot: {
      name:"Longshot",
      applyBaseMods(p){ p.base.bulletSpeed+=220; p.base.damage+=10; p.base.reload+=0.10; },
      fire(p,a){ fireBullet(p,a,p.bulletSpeed,p.damage,6); }
    },
    sprayer: {
      name:"Sprayer",
      applyBaseMods(p){ p.base.reload=Math.max(0.07,p.base.reload-0.06); p.base.damage=Math.max(8,p.base.damage-4); p.base.bulletSpeed-=60; },
      fire(p,a){
        const s=0.22;
        const dmg=Math.max(6,Math.floor(p.damage*0.7));
        fireBullet(p,a-s,p.bulletSpeed,dmg);
        fireBullet(p,a,p.bulletSpeed,dmg);
        fireBullet(p,a+s,p.bulletSpeed,dmg);
      }
    },
    twinheavy: {
      name:"Twin-Heavy",
      applyBaseMods(p){ p.base.maxHp+=40; p.hp=Math.min(p.base.maxHp,p.hp+40); p.base.moveSpeed-=20; p.base.damage+=6; p.base.reload+=0.02; },
      fire(p,a){ const s=0.07; fireBullet(p,a-s,p.bulletSpeed-40,p.damage+2,6); fireBullet(p,a+s,p.bulletSpeed-40,p.damage+2,6); }
    },
    cannonline: {
      name:"Cannonline",
      applyBaseMods(p){ p.base.damage+=12; p.base.reload+=0.12; p.base.bulletSpeed+=120; },
      fire(p,a){ fireBullet(p,a,p.bulletSpeed,p.damage+10,7); }
    },
    fortress: {
      name:"Fortress",
      applyBaseMods(p){ p.base.maxHp+=70; p.hp=Math.min(p.base.maxHp,p.hp+70); p.base.moveSpeed-=35; p.base.reload+=0.05; },
      fire(p,a){
        const dmg=Math.max(8,Math.floor(p.damage*0.9));
        fireBullet(p,a,p.bulletSpeed-60,dmg,6);
        fireBullet(p,a+0.35,p.bulletSpeed-80,dmg,6);
        fireBullet(p,a-0.35,p.bulletSpeed-80,dmg,6);
      }
    },
    splitshot: {
      name:"Splitshot",
      applyBaseMods(p){ p.base.moveSpeed+=35; p.base.reload=Math.max(0.08,p.base.reload-0.03); p.base.damage=Math.max(8,p.base.damage-2); },
      fire(p,a){
        const dmg=Math.max(5,Math.floor(p.damage*0.55));
        const step=0.18;
        [-2,-1,0,1,2].forEach(k => fireBullet(p, a+k*step, p.bulletSpeed-40, dmg));
      }
    },
    rapid: {
      name:"Rapid",
      applyBaseMods(p){ p.base.reload=Math.max(0.06,p.base.reload-0.08); p.base.damage=Math.max(7,p.base.damage-5); p.base.moveSpeed+=20; },
      fire(p,a){ fireBullet(p, a+rand(-0.05,0.05), p.bulletSpeed-30, p.damage); }
    },
    skirmisher: {
      name:"Skirmisher",
      applyBaseMods(p){ p.base.moveSpeed+=45; p.base.bulletSpeed+=60; p.base.damage=Math.max(9,p.base.damage-1); },
      fire(p,a){ const s=0.06; fireBullet(p,a-s,p.bulletSpeed,p.damage); fireBullet(p,a+s,p.bulletSpeed,p.damage); }
    }
  };

  function showClassChoices(){ if (classChoices) classChoices.style.display="block"; }
  function hideClassChoices(){ if (classChoices) classChoices.style.display="none"; }

  function openClassChoice(){
    const tree = TREES[player.equippedTreeId];
    if (!classChoices) return;
    classChoices.innerHTML = `
      <div style="margin-top:8px"><b>Choose a class</b> (Rank ${UNLOCK_RANK}) â€” Tree: ${tree.name}</div>
      <div style="opacity:.8;font-size:12px;margin-top:4px">${tree.desc}</div>
      <div id="classBtns" style="margin-top:6px"></div>
    `;
    const wrap = classChoices.querySelector("#classBtns");
    tree.classesAtRank10.forEach(clsId => {
      const btn = document.createElement("button");
      btn.textContent = CLASSES[clsId].name;
      btn.onclick = () => chooseClass(clsId);
      wrap.appendChild(btn);
    });
    showClassChoices();
  }

  function chooseClass(clsId){
    player.classId = clsId;
    player.classChosen = true;
    hideClassChoices();
    CLASSES[clsId].applyBaseMods?.(player);
    recalcDerivedStats(player);
  }

  // âœ… Safe derived stats (NPC safe too)
  function recalcDerivedStats(p){
    let moveSpeed = p.base.moveSpeed;
    let damage = p.base.damage;
    let bulletSpeed = p.base.bulletSpeed;
    let reload = p.base.reload;
    let maxHp = p.base.maxHp;
    let regen = p.base.regen;
    let regenDelay = p.base.regenDelay;

    let damageTakenMul = 1.0;
    const hasEffects = p.effects && typeof p.effects.values === "function";
    if (hasEffects){
      for (const eff of p.effects.values()){
        const m = eff.mods || {};
        if (m.moveSpeedMul) moveSpeed *= m.moveSpeedMul;
        if (m.damageMul) damage *= m.damageMul;
        if (m.bulletSpeedMul) bulletSpeed *= m.bulletSpeedMul;
        if (m.reloadMul) reload *= m.reloadMul;
        if (m.maxHpMul) maxHp *= m.maxHpMul;
        if (m.regenMul) regen *= m.regenMul;
        if (m.damageTakenMul) damageTakenMul *= m.damageTakenMul;
      }
    }

    p.damageTakenMul = damageTakenMul;
    p.moveSpeed = moveSpeed;
    p.damage = Math.max(1, Math.round(damage));
    p.bulletSpeed = bulletSpeed;
    p.reload = Math.max(0.05, reload);
    p.maxHp = Math.max(20, Math.round(maxHp));
    p.regen = regen;
    p.regenDelay = regenDelay;

    if (typeof p.hp === "number") p.hp = Math.min(p.hp, p.maxHp);
  }

  // ---------- XP
  function npcAutoSpendPoints(npc){
    const ups = ["damage","bulletSpeed","reload","moveSpeed","maxHp","regen"];
    while (npc.points > 0){
      applyStatUpgrade(npc, ups[(Math.random()*ups.length)|0]);
      npc.points--;
    }
    recalcDerivedStats(npc);
  }

  function gainXp(entity, amount){
    entity.xp += amount;
    while (entity.xp >= entity.xpNext){
      entity.xp -= entity.xpNext;
      entity.rank += 1;
      entity.points += 1;
      entity.xpNext = Math.floor(entity.xpNext * 1.16 + 12);

      if (entity.id === player.id){
        pendingRanks += 1;
        if (player.rank >= UNLOCK_RANK) player.classUnlocked = true;
      } else {
        npcAutoSpendPoints(entity);
      }
    }

    if (entity.id === player.id){
      if (pendingRanks > 0) showStatChoices();
      if (player.classUnlocked && !player.classChosen){
        hideStatChoices();
        pendingRanks = 0;
        openClassChoice();
      }
    }
  }

  function awardDiamonds(n){
    player.diamonds += n;
    updateHud();
    if (shopPanel && shopPanel.style.display==="block") renderShopAndInventory();
  }

  // ---------- Shapes
  function spawnShape(){
    const t = Math.random();
    let type = "square";
    if (t < 0.45) type = "triangle";
    else if (t < 0.85) type = "square";
    else type = "pent";

    const base = {
      x: rand(80, world.w-80),
      y: rand(80, world.h-80),
      vx: rand(-20,20),
      vy: rand(-20,20),
      rot: rand(0,Math.PI*2),
      rotSpd: rand(-1.2,1.2),
      hitFlash: 0
    };

    if (type==="triangle") shapes.push({ ...base, type, r:16, hp:35, maxHp:35, xp:8,  color:"#f6d365" });
    else if (type==="square") shapes.push({ ...base, type, r:20, hp:60, maxHp:60, xp:12, color:"#7ee8fa" });
    else shapes.push({ ...base, type, r:26, hp:110, maxHp:110, xp:22, color:"#c3a6ff" });
  }
  for (let i=0;i<45;i++) spawnShape();

  // ---------- Pickups
  function spawnPickup(typeId){
    const it = ITEMS[typeId];
    pickups.push({ id: typeId, x: rand(120, world.w-120), y: rand(120, world.h-120), r: 14, active: true, respawn: 0, color: it.color });
  }
  function seedPickups(){
    pickups.length = 0;
    const k = Object.keys(ITEMS);
    for (let i=0;i<10;i++) spawnPickup(k[i % k.length]);
  }
  function applyItemToPlayer(itemId){
    const it = ITEMS[itemId];
    const now = performance.now()/1000;
    player.effects.set(itemId, { expires: now + it.duration, mods: it.mods, name: it.name });
    recalcDerivedStats(player);
  }
  function updateItemEffects(){
    const now = performance.now()/1000;
    let changed=false;
    for (const [id, eff] of player.effects){
      if (eff.expires <= now){ player.effects.delete(id); changed=true; }
    }
    if (changed) recalcDerivedStats(player);
  }
  function describeActiveBuffs(){
    if (!buffTxt) return;
    if (player.effects.size === 0){ buffTxt.textContent = ""; return; }
    const now = performance.now()/1000;
    const parts = [];
    for (const eff of player.effects.values()){
      parts.push(`${eff.name} (${Math.max(0, eff.expires-now).toFixed(0)}s)`);
    }
    buffTxt.textContent = "Active items: " + parts.join(" â€¢ ");
  }

  // ---------- Bullets
  function fireBullet(owner, angle, speed, damage, radius=5){
    // bullet cap to reduce lag
    if (bullets.length > 700) return;

    const muzzle = owner.r + 16;
    bullets.push({
      ownerId: owner.id,
      x: owner.x + Math.cos(angle)*muzzle,
      y: owner.y + Math.sin(angle)*muzzle,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed,
      r: radius,
      dmg: damage,
      life: 1.9
    });
  }
  function shootPlayer(){
    if (player.shotCooldown > 0) return;
    player.shotCooldown = player.reload;
    const cls = CLASSES[player.classId];
    if (cls?.fire) cls.fire(player, player.angle);
    else fireBullet(player, player.angle, player.bulletSpeed, player.damage);
  }

  // ---------- Enemies
  let enemyIdCounter = 1;
  function spawnEnemy(){
    const preset = MODE_PRESETS[game.mode];
    const e = {
      id: "e"+(enemyIdCounter++),
      x: rand(120, world.w-120),
      y: rand(120, world.h-120),
      r: 16,
      angle: rand(0,Math.PI*2),

      base: {
        moveSpeed: rand(140,190) * preset.moveMul,
        bulletSpeed: rand(420,500),
        reload: rand(0.38,0.55) * preset.reloadMul,
        damage: rand(10,14) * preset.dmgMul,
        maxHp: 85,
        regen: 0.8,
        regenDelay: 1.6
      },

      moveSpeed: 160, bulletSpeed: 460, reload: 0.45, damage: 12,
      maxHp: 85, hp: 85, regen: 0.8, regenDelay: 1.6,
      sinceDamaged: 999,
      damageTakenMul: 1.0,

      shotCooldown: rand(0,0.3),
      alive: true,
      wanderDir: rand(0,Math.PI*2),
      wanderTimer: rand(0.6,1.6),

      rank: 1, xp: 0, xpNext: 70, points: 0,
      aimError: preset.aimError,

      effects: new Map()
    };
    recalcDerivedStats(e);
    e.hp = e.maxHp;
    enemies.push(e);
  }

  function resetStage(stageNum){
    enemies.length = 0;
    boss = null;
    game.phase = "fight";

    if (stageNum > MAX_STAGE){
      game.won = true;
      showHome();
      return;
    }

    player.hp = Math.min(player.maxHp, player.hp + Math.floor(player.maxHp*0.35));
    player.alive = true;

    const preset = MODE_PRESETS[game.mode];
    for (let i=0;i<preset.npcCount;i++) spawnEnemy();
  }

  // ---------- Boss
  function spawnBoss(){
    boss = {
      id: "boss",
      x: clamp(player.x + rand(-520,520), 250, world.w-250),
      y: clamp(player.y + rand(-520,520), 250, world.h-250),
      r: 110, maxHp: 1800, hp: 1800, alive: true, hitFlash: 0,
      moveSpeed: 95,
      shotCooldown: 0.9, shotTimer: 0.35,
      burstCooldown: 4.0, burstTimer: 2.0,
      dashCooldown: 6.0, dashTimer: 3.0,
      dashTime: 0, dashVX: 0, dashVY: 0
    };
    game.phase = "boss";
  }

  function livingTanksNoBoss(){
    const list = [];
    if (player.alive) list.push(player);
    enemies.forEach(e => e.alive && list.push(e));
    return list;
  }

  function findTargetForEnemy(){
    if (player.alive) return player;
    return null;
  }

  function killTank(t){
    t.alive = false;
    t.hp = 0;
    if (t.id === player.id) showHome();
  }

  // ---------- Home / Run
  function showHome(){
    if (homeMenu) homeMenu.style.display = "flex";
    game.state = "home";
    setHudOpen(false);
    if (startBtn) startBtn.textContent = (game.checkpointStage > 1) ? "Continue" : "Start";
    if (cpTxt) cpTxt.textContent = game.checkpointStage;
    if (winMsg) winMsg.style.display = game.won ? "block" : "none";
  }
  function hideHome(){
    if (homeMenu) homeMenu.style.display = "none";
  }

  function resetRun(){
    bullets.length = 0;

    player.x = world.w/2;
    player.y = world.h/2;

    player.base = { moveSpeed:240, damage:18, bulletSpeed:520, reload:0.22, maxHp:140, regen:2.0, regenDelay:1.25 };
    player.hp = 140;
    player.sinceDamaged = 999;

    player.rank = 1;
    player.xp = 0;
    player.xpNext = 70;
    player.points = 0;

    player.classId = "basic";
    player.classUnlocked = false;
    player.classChosen = false;

    player.shotCooldown = 0;
    player.effects.clear();

    recalcDerivedStats(player);
    player.hp = player.maxHp;

    game.stage = game.checkpointStage;
    game.won = false;

    seedPickups();
    resetStage(game.stage);
  }

  function startRun(){
    hideHome();
    resetRun();
    game.state = "play";
  }

  if (startBtn){
    startBtn.addEventListener("click", (e) => {
      if (e && e.shiftKey){ game.checkpointStage = 1; game.stage = 1; }
      startRun();
    });
  }

  // ---------- about:blank launcher + fullscreen
  function openInAboutBlank(){
    // open popup (must be from click)
    const w = window.open("about:blank", "_blank");
    if (!w){
      alert("Popup blocked. Allow popups for this site, then try again.");
      return;
    }

    // clone current game HTML into new window
    const html = "<!doctype html>\n" + document.documentElement.outerHTML;
    w.document.open();
    w.document.write(html);
    w.document.close();

    // Inject a small overlay in the new window:
    // - Fullscreen button
    // - HUD toggle
    const injectOverlay = () => {
      try{
        const doc = w.document;
        const body = doc.body;
        if (!body) { setTimeout(injectOverlay, 50); return; }

        // make sure canvas is visible
        const style = doc.createElement("style");
        style.textContent = `
          #blankOverlay{
            position:fixed;left:12px;bottom:12px;z-index:99999;
            display:flex;gap:10px;flex-wrap:wrap;
          }
          #blankOverlay button{
            padding:10px 14px;border-radius:14px;
            border:1px solid rgba(255,255,255,.18);
            background:rgba(255,255,255,.12);color:#e8eefc;
            font:14px system-ui,-apple-system,Segoe UI,Roboto,Arial;
            cursor:pointer;
          }
          #blankOverlay button:hover{background:rgba(255,255,255,.18)}
        `;
        doc.head.appendChild(style);

        const wrap = doc.createElement("div");
        wrap.id = "blankOverlay";

        const fsBtn = doc.createElement("button");
        fsBtn.textContent = "Enter Fullscreen";
        fsBtn.onclick = async () => {
          const el = doc.documentElement;
          if (el.requestFullscreen) await el.requestFullscreen();
        };

        const hudBtn = doc.createElement("button");
        hudBtn.textContent = "Toggle HUD";
        hudBtn.onclick = () => {
          const hud = doc.getElementById("hud");
          const ui = doc.getElementById("uiBtn");
          const bd = doc.getElementById("uiBackdrop");
          if (hud){
            const isHidden = (hud.style.display === "none");
            hud.style.display = isHidden ? "" : "none";
            if (ui) ui.style.display = isHidden ? "" : "none";
            if (bd) bd.style.display = "none";
          }
        };

        const homeBtn = doc.createElement("button");
        homeBtn.textContent = "Home";
        homeBtn.onclick = () => {
          // click the game's internal Home menu by calling showHome if exists; otherwise reload
          // simplest: reload will bring home menu back
          w.location.reload();
        };

        wrap.appendChild(fsBtn);
        wrap.appendChild(hudBtn);
        wrap.appendChild(homeBtn);

        body.appendChild(wrap);

        // small improvement: close the home menu automatically in new window if already playing
        // (if user clicked "Play in about:blank", they likely want to start there)
        // We'll try to click Start automatically only if menu is visible.
        setTimeout(() => {
          const hm = doc.getElementById("homeMenu");
          const sb = doc.getElementById("startBtn");
          if (hm && sb && hm.style.display !== "none"){
            // do NOT auto-click Start (some browsers block). Keep user control.
          }
        }, 200);

      } catch(e){
        setTimeout(injectOverlay, 80);
      }
    };

    w.addEventListener("load", () => injectOverlay(), { once:true });
  }

  if (blankBtn){
    blankBtn.addEventListener("click", openInAboutBlank);
  }

  // ---------- HUD update
  function updateHud(){
    if (hpTxt) hpTxt.textContent = `${Math.ceil(player.hp)} / ${player.maxHp}`;
    if (hpFill) hpFill.style.width = `${(player.hp/player.maxHp)*100}%`;
    if (rgTxt) rgTxt.textContent = player.regen.toFixed(1);

    if (lvTxt) lvTxt.textContent = player.rank;
    if (xpTxt) xpTxt.textContent = `${Math.floor(player.xp)} / ${player.xpNext}`;
    if (xpFill) xpFill.style.width = `${(player.xp/player.xpNext)*100}%`;

    if (ptTxt) ptTxt.textContent = player.points;
    if (diaTxt) diaTxt.textContent = player.diamonds;

    const preset = MODE_PRESETS[game.mode];
    if (modeTxt) modeTxt.textContent = preset.name;
    if (npcTxt) npcTxt.textContent = preset.npcCount;
    if (itmTxt) itmTxt.textContent = String(pickups.filter(p=>p.active).length);

    describeActiveBuffs();
  }

  // ---------- Init
  setMode("easy");
  renderItemDescriptions();
  seedPickups();
  recalcDerivedStats(player);
  renderShopAndInventory();
  updateHud();
  showHome();

  // ---------- Main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(dt){
    if (game.state === "home"){ updateHud(); return; }

    updateItemEffects();

    // aim
    updateCamera(player.x, player.y);
    let aimX = cam.x + mouse.x;
    let aimY = cam.y + mouse.y;
    if (touch.enabled && touch.aim.active){
      aimX = player.x + touch.aim.vx * 220;
      aimY = player.y + touch.aim.vy * 220;
    }
    player.angle = angleTo(player.x, player.y, aimX, aimY);

    // move
    if (player.alive){
      let ix=0, iy=0;
      if (keys.has("w")||keys.has("arrowup")) iy -= 1;
      if (keys.has("s")||keys.has("arrowdown")) iy += 1;
      if (keys.has("a")||keys.has("arrowleft")) ix -= 1;
      if (keys.has("d")||keys.has("arrowright")) ix += 1;
      if (touch.enabled){ ix += touch.move.vx; iy += touch.move.vy; }
      const l = Math.hypot(ix,iy) || 1;
      ix/=l; iy/=l;
      player.x += ix*player.moveSpeed*dt;
      player.y += iy*player.moveSpeed*dt;
      player.x = clamp(player.x, player.r, world.w-player.r);
      player.y = clamp(player.y, player.r, world.h-player.r);
    }

    // shoot
    player.shotCooldown -= dt;
    if ((mouse.down || (touch.enabled && touch.shoot)) && player.alive && !menusOpen()) shootPlayer();

    // pickups
    for (const p of pickups){
      if (!p.active) continue;
      if (player.alive && circleHit(player.x,player.y,player.r, p.x,p.y,p.r)){
        p.active = false;
        p.respawn = rand(10,16);
        applyItemToPlayer(p.id);
      }
    }
    for (const p of pickups){
      if (p.active) continue;
      p.respawn -= dt;
      if (p.respawn <= 0){
        p.x = rand(120, world.w-120);
        p.y = rand(120, world.h-120);
        p.active = true;
      }
    }

    // enemies
    for (const e of enemies){
      if (!e.alive) continue;

      e.sinceDamaged += dt;
      if (e.sinceDamaged >= e.regenDelay && e.hp > 0 && e.hp < e.maxHp){
        e.hp = Math.min(e.maxHp, e.hp + e.regen * dt);
      }

      e.wanderTimer -= dt;
      if (e.wanderTimer <= 0){
        e.wanderTimer = rand(0.6,1.6);
        e.wanderDir = rand(0,Math.PI*2);
      }

      const t = findTargetForEnemy(e);
      if (t){
        const ang = angleTo(e.x, e.y, t.x, t.y);
        e.angle = ang + rand(-e.aimError, e.aimError);
        const mixed = ang*0.7 + e.wanderDir*0.3;
        e.x += Math.cos(mixed)*e.moveSpeed*dt;
        e.y += Math.sin(mixed)*e.moveSpeed*dt;
      } else {
        e.x += Math.cos(e.wanderDir)*e.moveSpeed*dt;
        e.y += Math.sin(e.wanderDir)*e.moveSpeed*dt;
      }
      e.x = clamp(e.x, e.r, world.w-e.r);
      e.y = clamp(e.y, e.r, world.h-e.r);

      e.shotCooldown -= dt;
      if (e.shotCooldown <= 0 && t){
        e.shotCooldown = e.reload;
        fireBullet(e, e.angle, e.bulletSpeed, e.damage);
      }
    }

    // boss spawn
    if (game.phase === "fight"){
      const alive = livingTanksNoBoss();
      if (player.alive && alive.length === 1){
        spawnBoss();
      }
    }

    // boss AI
    if (boss && boss.alive){
      boss.hitFlash = Math.max(0, boss.hitFlash - dt);
      const ang = angleTo(boss.x, boss.y, player.x, player.y);

      if (boss.dashTime > 0){
        boss.dashTime -= dt;
        boss.x += boss.dashVX * dt;
        boss.y += boss.dashVY * dt;
      } else {
        boss.x += Math.cos(ang) * boss.moveSpeed * dt;
        boss.y += Math.sin(ang) * boss.moveSpeed * dt;

        boss.dashTimer -= dt;
        if (boss.dashTimer <= 0){
          boss.dashTimer = boss.dashCooldown;
          const dashSpeed = 700;
          boss.dashVX = Math.cos(ang) * dashSpeed;
          boss.dashVY = Math.sin(ang) * dashSpeed;
          boss.dashTime = 0.18;
        }
      }

      boss.x = clamp(boss.x, boss.r, world.w-boss.r);
      boss.y = clamp(boss.y, boss.r, world.h-boss.r);

      boss.shotTimer -= dt;
      if (boss.shotTimer <= 0){
        boss.shotTimer = boss.shotCooldown;
        const spread = 0.08;
        fireBullet(boss, ang-spread, 520, 18, 7);
        fireBullet(boss, ang,        520, 18, 7);
        fireBullet(boss, ang+spread, 520, 18, 7);
      }

      boss.burstTimer -= dt;
      if (boss.burstTimer <= 0){
        boss.burstTimer = boss.burstCooldown;
        const count = 18;
        for (let i=0;i<count;i++){
          const a = (Math.PI*2) * (i/count);
          fireBullet(boss, a, 420, 14, 6);
        }
      }

      if (player.alive && circleHit(boss.x,boss.y,boss.r, player.x,player.y,player.r)){
        player.hp -= (40 * dt) * (player.damageTakenMul ?? 1.0);
        player.sinceDamaged = 0;
        if (player.hp <= 0) killTank(player);
      }
    }

    // bullets
    // quick camera cull for collision checks
    const margin = 300;
    const viewL = cam.x - margin;
    const viewT = cam.y - margin;
    const viewR = cam.x + window.innerWidth + margin;
    const viewB = cam.y + window.innerHeight + margin;

    for (let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      b.life -= dt;

      if (b.life <= 0 || b.x<-60 || b.y<-60 || b.x>world.w+60 || b.y>world.h+60){
        bullets.splice(i,1);
        continue;
      }

      // skip collision checks if way offscreen (perf)
      if (b.x < viewL || b.x > viewR || b.y < viewT || b.y > viewB) continue;

      // hit shapes
      let hit=false;
      for (let j=shapes.length-1;j>=0;j--){
        const s = shapes[j];
        if (circleHit(b.x,b.y,b.r, s.x,s.y,s.r)){
          s.hp -= b.dmg;
          s.hitFlash = 0.10;
          bullets.splice(i,1);
          hit=true;

          if (s.hp <= 0){
            const owner = (b.ownerId === player.id) ? player : enemies.find(e=>e.id===b.ownerId);
            if (owner) gainXp(owner, s.xp * MODE_PRESETS[game.mode].xpMul);
            shapes.splice(j,1);
            spawnShape();
          }
          break;
        }
      }
      if (hit) continue;

      // hit player
      if (player.alive && b.ownerId !== player.id && circleHit(b.x,b.y,b.r, player.x,player.y,player.r)){
        player.hp -= b.dmg * (player.damageTakenMul ?? 1.0);
        player.sinceDamaged = 0;
        bullets.splice(i,1);
        if (player.hp <= 0) killTank(player);
        continue;
      }

      // hit enemies
      for (const e of enemies){
        if (!e.alive) continue;
        if (b.ownerId === e.id) continue;
        if (circleHit(b.x,b.y,b.r, e.x,e.y,e.r)){
          e.hp -= b.dmg * (e.damageTakenMul ?? 1.0);
          e.sinceDamaged = 0;
          bullets.splice(i,1);

          if (e.hp <= 0){
            e.alive = false;
            if (b.ownerId === player.id){
              gainXp(player, 18 * MODE_PRESETS[game.mode].xpMul);
              awardDiamonds(DIAMONDS_PER_KILL);
            }
          }
          hit=true;
          break;
        }
      }
      if (hit) continue;

      // hit boss
      if (boss && boss.alive && b.ownerId !== boss.id && circleHit(b.x,b.y,b.r, boss.x,boss.y,boss.r)){
        boss.hp -= b.dmg;
        boss.hitFlash = 0.12;
        bullets.splice(i,1);
        if (boss.hp <= 0){
          boss.alive = false;
          game.stage += 1;
          if (game.stage % CHECKPOINT_EVERY === 1 && game.stage > 1) game.checkpointStage = game.stage;
          if (game.stage > MAX_STAGE){
            game.won = true;
            showHome();
          } else {
            resetStage(game.stage);
          }
        }
      }
    }

    // shapes drift + regen
    for (const s of shapes){
      s.x += s.vx*dt; s.y += s.vy*dt;
      s.rot += s.rotSpd*dt;
      s.hitFlash = Math.max(0, s.hitFlash - dt);
      if (s.x < s.r || s.x > world.w-s.r){ s.vx *= -1; s.x = clamp(s.x, s.r, world.w-s.r); }
      if (s.y < s.r || s.y > world.h-s.r){ s.vy *= -1; s.y = clamp(s.y, s.r, world.h-s.r); }
    }

    if (player.alive){
      player.sinceDamaged += dt;
      if (player.sinceDamaged >= player.regenDelay && player.hp > 0 && player.hp < player.maxHp){
        player.hp = Math.min(player.maxHp, player.hp + player.regen * dt);
      }
    }

    updateCamera(player.x, player.y);
    updateHud();
  }

  // ---------- Drawing
  function draw(){
    ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
    drawGrid();

    ctx.save();
    ctx.translate(-cam.x, -cam.y);

    pickups.forEach(drawPickup);
    shapes.forEach(drawShape);

    ctx.fillStyle="#f1f5ff";
    bullets.forEach(b => {
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fill();
    });

    enemies.forEach(e => e.alive && drawTank(e, "#ff6b8a", "#ffd0da"));
    if (boss && boss.alive) drawBoss(boss);
    if (player.alive) drawTank(player, "#4aa3ff", "#9ad0ff");

    ctx.restore();
  }

  function drawGrid(){
    const grid=60;
    const ox = -(cam.x % grid);
    const oy = -(cam.y % grid);

    ctx.fillStyle="#0b0f1a";
    ctx.fillRect(0,0,window.innerWidth,window.innerHeight);

    ctx.strokeStyle="rgba(255,255,255,0.06)";
    ctx.lineWidth=1;
    ctx.beginPath();
    for (let x=ox;x<window.innerWidth;x+=grid){ ctx.moveTo(x,0); ctx.lineTo(x,window.innerHeight); }
    for (let y=oy;y<window.innerHeight;y+=grid){ ctx.moveTo(0,y); ctx.lineTo(window.innerWidth,y); }
    ctx.stroke();
  }

  function drawPickup(p){
    if (!p.active) return;
    const it = ITEMS[p.id];
    ctx.save();
    ctx.translate(p.x,p.y);

    ctx.fillStyle = it.color;
    ctx.strokeStyle = "rgba(0,0,0,0.28)";
    ctx.lineWidth = 2;

    ctx.beginPath();
    polygonPath(ctx, 6, p.r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.beginPath();
    ctx.arc(0,0,2.2,0,Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawTank(t, bodyColor, turretColor){
    ctx.save();
    ctx.translate(t.x,t.y);
    ctx.rotate(t.angle);

    ctx.strokeStyle="rgba(0,0,0,0.25)";
    ctx.lineWidth=2;
    ctx.fillStyle=turretColor;
    roundRect(ctx, 0, -6, t.r+18, 12, 6); ctx.fill(); ctx.stroke();

    ctx.restore();

    ctx.fillStyle=bodyColor;
    ctx.strokeStyle="rgba(0,0,0,0.25)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(t.x,t.y,t.r,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();

    const hpPct = clamp(t.hp/t.maxHp, 0, 1);
    ctx.fillStyle="rgba(0,0,0,0.35)";
    ctx.fillRect(t.x-22, t.y+t.r+10, 44, 6);
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.fillRect(t.x-22, t.y+t.r+10, 44*hpPct, 6);
  }

  function drawBoss(b){
    ctx.save();
    ctx.translate(b.x,b.y);

    const flash = b.hitFlash > 0;
    ctx.fillStyle = flash ? "rgba(255,255,255,0.92)" : "rgba(180,120,255,0.95)";
    ctx.strokeStyle = "rgba(0,0,0,0.30)";
    ctx.lineWidth = 4;

    ctx.beginPath();
    ctx.arc(0,0,b.r,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();

    ctx.restore();
  }

  function drawShape(s){
    ctx.save();
    ctx.translate(s.x,s.y);
    ctx.rotate(s.rot);

    const flash = s.hitFlash > 0;
    ctx.fillStyle = flash ? "rgba(255,255,255,0.85)" : s.color;
    ctx.strokeStyle = "rgba(0,0,0,0.22)";
    ctx.lineWidth = 2;

    ctx.beginPath();
    if (s.type==="triangle") polygonPath(ctx,3,s.r);
    else if (s.type==="square") polygonPath(ctx,4,s.r);
    else polygonPath(ctx,5,s.r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.restore();
  }

  function polygonPath(ctx, sides, radius){
    const a = (Math.PI*2)/sides;
    ctx.moveTo(Math.cos(0)*radius, Math.sin(0)*radius);
    for (let i=1;i<=sides;i++) ctx.lineTo(Math.cos(a*i)*radius, Math.sin(a*i)*radius);
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }
})();
</script>
</body>
</html>
